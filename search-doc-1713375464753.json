{"searchDocs":[{"title":"Default rendering","type":0,"sectionRef":"#","url":"/smithy4s/docs/codegen/customisation/default-rendering","content":"Default rendering Smithy4s allows you to customize how defaults on the fields of smithy structures are rendered inside of case classes. There are three options: FULLOPTION_ONLYNONE The default is FULL. This value is set using metadata which means that the setting will be applied to all the rendering done by smithy4s. FULL​ FULL means that default values are rendered for all field types. For example: metadata smithy4sDefaultRenderMode = &quot;FULL&quot; structure FullExample { one: Integer = 1 two: String @required three: String } would render to something like: case class FullExample(three: String, one: Int = 1, two: Option[String] = None) Notice how the fields above are ordered. The reason for this is that fields are ordered as: Required FieldsFields with defaultsOptional Fields OPTION_ONLY​ metadata smithy4sDefaultRenderMode = &quot;OPTION_ONLY&quot; structure OptionExample { one: Integer = 1 two: String @required three: String } would render to something like: case class FullExample(one: String, three: String, two: Option[String] = None) Now one doesn't have a default rendered and as such it is placed first in the case class. NONE​ metadata smithy4sDefaultRenderMode = &quot;NONE&quot; structure OptionExample { one: Integer = 1 two: String @required three: String } would render to something like: case class FullExample(one: String, two: Option[String], three: String) Now none of the fields are rendered with defaults. As such, the order of the fields is the same as is defined in the smithy structure. caution The presence of the smithy4sDefaultRenderMode metadata does NOT change the way smithy4s codecs behave. As such, defaults will still be used when decoding fields inside of clients and servers. This feature is purely for changing the generated code for your convenience.","keywords":"","version":"Next"},{"title":"Specialised collection types","type":0,"sectionRef":"#","url":"/smithy4s/docs/codegen/customisation/collections","content":"Specialised collection types Smithy supports list and set, Smithy4s renders that to List[A] and Set[A] respectively. You can also use the @uniqueItems annotation on list which is equivalent to set. Smithy4s has support for two specialized collection types: Vector and IndexedSeq. The following examples show how to use them: use smithy4s.meta#indexedSeq use smithy4s.meta#vector @indexedSeq list SomeIndexSeq { member: String } @vector list SomeVector { member: String } Both annotations are only applicable on list shapes. You can't mix @vector with @indexedSeq, and neither one can be used with @uniqueItems.","keywords":"","version":"Next"},{"title":"Error Unions representation","type":0,"sectionRef":"#","url":"/smithy4s/docs/codegen/customisation/error-unions","content":"Error Unions representation By default, smithy4s renders service operations errors as ADTs. For example the following spec: operation Operation { input: Unit, output: Unit, errors: [BadRequest, InternalServerError] } @error(&quot;client&quot;) structure BadRequest { @required reason: String } @error(&quot;server&quot;) structure InternalServerError { @required stackTrace: String } will generate following scala types (simplified for brevity): case class BadRequest(reason: String) extends Throwable case class InternalServerError(stackTrace: String) extends Throwable sealed trait OperationError object OperationError extends ShapeTag.Companion[OperationError] { case class BadRequestCase(badRequest: BadRequest) extends OperationError case class InternalServerErrorCase(internalServerError: InternalServerError) extends OperationError } For Scala 3 users that would like to use native union representation for error types, smithy4s exposes a metadata flag smithy4sErrorsAsScala3Unions (defaults to false). After adding: metadata smithy4sErrorsAsScala3Unions = true to any of the smithy files used for code generation, the following representation will be rendered instead: case class BadRequest(reason: String) extends Throwable case class InternalServerError(stackTrace: String) extends Throwable type OperationError = BadRequest | InternalServerError ","keywords":"","version":"Next"},{"title":"Managing code size","type":0,"sectionRef":"#","url":"/smithy4s/docs/codegen/customisation/managing-code-size","content":"","keywords":"","version":"Next"},{"title":"Example​","type":1,"pageTitle":"Managing code size","url":"/smithy4s/docs/codegen/customisation/managing-code-size#example","content":"Let's say you decided to build a service that uses AWS Comprehend to detect sentiment in text provided by the user. You start with the smithy4s.g8 template, and, following the AWS support documentation, instruct Smithy4s plugin to generate you a client SDK for Comprehend:  smithy4sAwsSpecs ++= Seq(AWS.comprehend)  As you run compile in your build tool, you can see that there are 428 files being compiled. Uh-oh. Those 428 files cover the entirety of Comprehend's 84 operations and all the datatypes supporting them. But we don't need all of these operations - we only care about DetectSentiment. ","version":"Next","tagName":"h2"},{"title":"@only annotation​","type":1,"pageTitle":"Managing code size","url":"/smithy4s/docs/codegen/customisation/managing-code-size#only-annotation","content":"To express exactly that, Smithy4s ships with a built-in annotation smithy4s.meta#only, which can be applied to operations (and operations only) that you would like to keep in generated code, along with all the other Smithy shapes they reference. The exact semantics of the annotation are as follows: It can only be applied to operationsFor any service that has operations tagged with this annotation, the rest of the operations will be removed, along with all the shapes (structures, aliases, unions, enums, etc.) that those operations reference, as long as those shapes are deemed removable (see below)A shape is deemed removable if it's only reachable from the removed operations (either directly or transitively)Services that don't have any operations tagged with this annotation are assumed to have all of their operations tagged implicitly (so that all the operations are kept) The key mechanism that allows this operation to be usable with AWS client generation is that we can apply annotations post factum on shapes defined elsewhere. So to only preserve DetectSentiment operation, we can create a Smithy file in our project with these contents: $version: &quot;2&quot; namespace my.code use smithy4s.meta#only apply com.amazonaws.comprehend#DetectSentiment @only  The namespace here doesn't matter. com.amazonaws.comprehend#DetectSentiment is a fully qualified name referring to the DetectSentiment operation in AWS Comprehend. If we re-run the code generation, it will only produce 15 files! This will dramatically speed up the compilation and improve the JAR size. You can apply this annotation to as many operations as you want: $version: &quot;2&quot; namespace my.code use smithy4s.meta#only apply com.amazonaws.comprehend#DetectSentiment @only apply com.amazonaws.comprehend#CreateEntityRecognizer @only apply com.amazonaws.comprehend#CreateFlywheel @only // etc.  ","version":"Next","tagName":"h3"},{"title":"Serialisation overview","type":0,"sectionRef":"#","url":"/smithy4s/docs/02.1-serialisation/serialisation","content":"","keywords":"","version":"Next"},{"title":"Document (JSON-like adt)​","type":1,"pageTitle":"Serialisation overview","url":"/smithy4s/docs/02.1-serialisation/serialisation#document-json-like-adt","content":"The smithy4s-core module provides a smithy4s.Document datatype that is used in code-generation when document shapes are used in smithy. Document is effectively a JSON ADT, and can be easily converted to from other ADTs, such as the one provided by the Circe library. Document also comes with its own Encoder and Decoder construct, for which instances can be derived for every datatype generated by Smithy4s. import smithy4s.example.hello.Person import smithy4s.Document val personEncoder = Document.Encoder.fromSchema(Person.schema) // personEncoder: Document.Encoder[Person] = smithy4s.Document$CachedEncoderCompilerImpl$$anon$1@3769a29 val personDocument = personEncoder.encode(Person(name = &quot;John Doe&quot;)) // personDocument: Document = DObject( // value = Map(&quot;name&quot; -&gt; DString(value = &quot;John Doe&quot;)) // ) val personDecoder = Document.Decoder.fromSchema(Person.schema) // personDecoder: Document.Decoder[Person] = smithy4s.Document$Decoder$$anon$2@61fa0f32 val maybePerson = personDecoder.decode(personDocument) // maybePerson: Either[smithy4s.codecs.PayloadError, Person] = Right( // value = Person(name = &quot;John Doe&quot;, town = None) // )  By default, smithy4s Documents abide by the same semantics as smithy4s-json (see section below). It is worth noting that, although Document is isomorphic to a JSON ADT, its .toString is not valid JSON. Likewise, the smithy4s-core module does not contain logic to parse JSON strings into Documents. In order to read/write Documents from/to JSON strings, you need the smithy4s-json module. The smithy4s.json.Json entry-point contains methods that work with Documents. ","version":"Next","tagName":"h3"},{"title":"JSON​","type":1,"pageTitle":"Serialisation overview","url":"/smithy4s/docs/02.1-serialisation/serialisation#json","content":"The smithy4s-json module provides jsoniter-based encoders/decoders that can read/write generated data-types from/to JSON bytes/strings, without an intermediate JSON ADT. The performance of this module is very competitive are very competitive in the Scala ecosystem. This module is provided at the following coordinates : sbt : &quot;com.disneystreaming.smithy4s&quot; %% &quot;smithy4s-json&quot; % &quot;0.18.16&quot; mill : &quot;com.disneystreaming.smithy4s::smithy4s-json:0.18.16&quot;  The entrypoint for JSON parsing/writing is smithy4s.json.Json. See below for example usage. import smithy4s.example.hello.Person import smithy4s.Blob import smithy4s.json.Json val personEncoder = Json.payloadCodecs.encoders.fromSchema(Person.schema) // personEncoder: smithy4s.codecs.package.PayloadEncoder[Person] = smithy4s.json.internals.JsonPayloadCodecCompilerImpl$$anon$1$$anonfun$fromSchema$2@5da5cf7b val personJSON = personEncoder.encode(Person(name = &quot;John Doe&quot;)).toUTF8String // personJSON: String = &quot;{\\&quot;name\\&quot;:\\&quot;John Doe\\&quot;}&quot; val personDecoder = Json.payloadCodecs.decoders.fromSchema(Person.schema) // personDecoder: smithy4s.codecs.package.PayloadDecoder[Person] = smithy4s.json.internals.JsonPayloadCodecCompilerImpl$JsonPayloadDecoder@79e8f4e2 val maybePerson = personDecoder.decode(Blob(personJSON)) // maybePerson: Either[smithy4s.codecs.PayloadError, Person] = Right( // value = Person(name = &quot;John Doe&quot;, town = None) // )  By default, smithy4s-json abides by the semantics of : [official smithy traits], including: jsonNametimestampFormatsparserequireddefault. It is worth noting that, by default, Smithy4s chooses to not serialise default values if the when the member is optional. alloy traits ","version":"Next","tagName":"h3"},{"title":"XML​","type":1,"pageTitle":"Serialisation overview","url":"/smithy4s/docs/02.1-serialisation/serialisation#xml","content":"The smithy4s-xml module provides fs2-data encoders/decoders that can read/write generated data-types from/to XML bytes/strings. It is provided at the following coordinates : sbt : &quot;com.disneystreaming.smithy4s&quot; %% &quot;smithy4s-xml&quot; % &quot;0.18.16&quot; mill : &quot;com.disneystreaming.smithy4s::smithy4s-xml:0.18.16&quot;  The entrypoint for smithy4s.xml.Xml. See below for example usage. import smithy4s.example.hello.Person import smithy4s.Blob import smithy4s.xml.Xml val personEncoder = Xml.encoders.fromSchema(Person.schema) // personEncoder: smithy4s.codecs.package.BlobEncoder[Person] = smithy4s.xml.internals.XmlPayloadEncoderCompilerImpl$$anonfun$fromSchema$2@69796c83 val personXML = personEncoder.encode(Person(name = &quot;John Doe&quot;)).toUTF8String // personXML: String = &quot;&lt;Person&gt;&lt;name&gt;John Doe&lt;/name&gt;&lt;/Person&gt;&quot; val personDecoder = Xml.decoders.fromSchema(Person.schema) // personDecoder: smithy4s.codecs.package.BlobDecoder[Person] = smithy4s.xml.Xml$$anon$1$$anon$2@58cb6d01 val maybePerson = personDecoder.decode(Blob(personXML)) // maybePerson: Either[smithy4s.codecs.PayloadError, Person] = Right( // value = Person(name = &quot;John Doe&quot;, town = None) // )  By default, smithy4s-xml abides by the semantics of : official XML-related smithy traits ","version":"Next","tagName":"h3"},{"title":"Protobuf​","type":1,"pageTitle":"Serialisation overview","url":"/smithy4s/docs/02.1-serialisation/serialisation#protobuf","content":"The smithy4s-protobuf module provides protocol-buffers codecs that can read/write generated data-types from protobuf-encoded bytes. sbt : &quot;com.disneystreaming.smithy4s&quot; %% &quot;smithy4s-protobuf&quot; % &quot;0.18.16&quot; mill : &quot;com.disneystreaming.smithy4s::smithy4s-protobuf:0.18.16&quot;  The entrypoint for XML parsing/writing is smithy4s.protobuf.Protobuf. See below for example usage. import smithy4s.example.hello.Person import smithy4s.protobuf.Protobuf val personCodec = Protobuf.codecs.fromSchema(Person.schema) // personCodec: smithy4s.protobuf.ProtobufCodec[Person] = smithy4s.protobuf.ProtobufCodec$$anon$1@2b66bf74 val personBytes = personCodec.writeBlob(Person(name = &quot;John Doe&quot;)) // personBytes: smithy4s.Blob = ArraySliceBlob(..., 0, 10) val maybePerson = personCodec.readBlob(personBytes) // maybePerson: Either[smithy4s.protobuf.ProtobufReadError, Person] = Right( // value = Person(name = &quot;John Doe&quot;, town = None) // )  By default, smithy4s-protobuf abides by the semantics of : alloy protobuf traits. These semantics are the exact same semantics that smithy-translate uses to translate smithy to protobuf. This implies that the Smithy4s protobuf codecs are compatible with the codecs of other protobuf tools, generated from the .proto files resulting from running smithy through smithy-translate. In short, Smithy4s and ScalaPB can talk to each other : the ScalaPB codecs generated from protobuf after a translation from smithy are able to decode binary data produced by Smithy4s protobuf codecs (and vice versa). ┌────────────────────┐ ┌────────────────────┐ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ Smithy IDL ├────────────────────────► Protobuf IDL │ │ │ smithy-translate │ │ │ │ │ │ │ │ │ │ │ │ │ │ └─────────┬──────────┘ └─────────┬──────────┘ │ │ │ │ │ │ │ │ │ │ │ │ │ Smithy4s codegen │ ScalaPB codegen │ │ │ │ │ │ │ │ │ │ ┌─────────▼──────────┐ ┌─────────▼──────────┐ │ │ │ │ │ │ │ │ │ │ │ │ │ ◄────────────────────────┤ │ │ Smithy4s code │ Runtime communication │ ScalaPB code │ │ ├────────────────────────► │ │ │ │ │ │ │ │ │ │ │ │ │ └────────────────────┘ └────────────────────┘  ","version":"Next","tagName":"h3"},{"title":"Algebraic data types","type":0,"sectionRef":"#","url":"/smithy4s/docs/codegen/customisation/adts","content":"","keywords":"","version":"Next"},{"title":"smithy4s.meta#adt Trait​","type":1,"pageTitle":"Algebraic data types","url":"/smithy4s/docs/codegen/customisation/adts#smithy4smetaadt-trait","content":"Adding the smithy4s.meta#adt trait to a OrderType union changes how the code for that union is generated. @adt // added the adt trait here union OrderType { inStore: InStoreOrder } structure InStoreOrder { @required id: OrderNumber locationId: String }  sealed trait OrderType extends scala.Product with scala.Serializable case class InStoreOrder(id: OrderNumber, locationId: Option[String] = None) extends OrderType  The IsStoreOrder class has now been updated to be rendered directly as a member of the OrderTypesealed hierarchy instead of in its own file. Restrictions and Validation​ Using the adt trait does come with some restrictions. First are requirements for the union which is annotated with the adt trait: The union must contain at least one memberThe union's members must only target structure shapes Additionally, there is a requirement that is added onto the structure shapes that the union targets: The structures must NOT be the target of any other union, structure, etc. They can only be the target in the ONE union that is annotated with the adt trait. A validator will be run automatically on your model to make sure it conforms to the requirements above. Note: The adt trait has NO impact on the serialization/deserialization behaviors of Smithy4s. The only thing it changes is what the generated code looks like. This is accomplished by keeping the rendered schemas equivalent, even if the case class is rendered in a different place. Mixins​ The adt trait has some extra functionality in place to improve ergonomics when working with the generated code. Specifically, the smithy4s code generation will extract all common mixins from the structure members the union targets and move them to the level of the sealed trait that represents the adt. This is easier to conceptualize with an example: @adt union OrderType { inStore: InStoreOrder online: OnlineOrder } @mixin structure HasId { @required id: String } @mixin structure HasLocation { @required locationId: String } structure InStoreOrder with [HasId, HasLocation] { description: String } structure OnlineOrder with [HasId] { @required userId: String }  This Smithy model will lead to the following generated code: HasId.scala: trait HasId { def id: String }  HasLocation.scala: trait HasLocation { def locationId: String }  sealed trait OrderType extends HasId scala.Product with scala.Serializable case class InStoreOrder(id: String, locationId: String) extends OrderType with HasLocation case class OnlineOrder(id: String, userId: String) extends OrderType  Since both OnlineOrder and InStoreOrder use the HasId mixin, that mixin is moved to the OrderType level in the generated code. This allows for more flexibility when working with adts. Since only InStoreOrder uses the HasLocation mixin, that mixin is kept at the level of InStoreOrder and extended directly by that case class. ","version":"Next","tagName":"h2"},{"title":"smithy4s.meta#adtMember Trait​","type":1,"pageTitle":"Algebraic data types","url":"/smithy4s/docs/codegen/customisation/adts#smithy4smetaadtmember-trait","content":"Below we will explore the smithy4s.meta#adtMember trait. This trait is mutually exclusive from the adt trait described above. It has essentially the same effect as the adt trait, with the exception that it DOES NOT extract common mixins to the sealed trait level like the adt trait does. Here is an example of using the adtMember trait: union OrderType { inStore: InStoreOrder } @adtMember(OrderType) // added the adtMember trait here structure InStoreOrder { @required id: OrderNumber locationId: String }  sealed trait OrderType extends scala.Product with scala.Serializable case class InStoreOrder(id: OrderNumber, locationId: Option[String] = None) extends OrderType  The IsStoreOrder class has now been updated to be rendered directly as a member of the OrderTypesealed hierarchy. The adtMember trait can be applied to any structure as long as said structure is targeted by EXACTLY ONE union.This means it must be targeted by the union that is provided as parameter to the adtMember trait. This constraint is fulfilled above because OrderType targets InStoreOrder and InStoreOrder is annotated with @adtMember(OrderType). The structure annotated with adtMember (e.g. InStoreOrder) also must not be targeted by any other structures or unions in the model. There is a validator that will make sure these requirements are met whenever the adtMember trait is in use. Note: The adtMember trait has NO impact on the serialization/deserialization behaviors of Smithy4s. The only thing it changes is what the generated code looks like. This is accomplished by keeping the rendered schemas equivalent, even if the case class is rendered in a different place. ","version":"Next","tagName":"h2"},{"title":"Nullable Values","type":0,"sectionRef":"#","url":"/smithy4s/docs/codegen/customisation/nullable-values","content":"","keywords":"","version":"Next"},{"title":"Combinations with other annotations​","type":1,"pageTitle":"Nullable Values","url":"/smithy4s/docs/codegen/customisation/nullable-values#combinations-with-other-annotations","content":"The annotation @nullable can be combined with both @required and @default, with the following effects: annotating as @required will forbid the field from being omitted but permit null to be passed explicitly on deserialization. It will always include the field but potentially set it to null on serialization.annotating as @default works the same as default values for non-nullable fields, with the exception that the default can be set to null and not automatically adjusted into a &quot;zero value&quot; In both cases, the resulting Scala type of the field will be smithy.Nullable[T]. ","version":"Next","tagName":"h2"},{"title":"Open Enumerations","type":0,"sectionRef":"#","url":"/smithy4s/docs/codegen/customisation/open-enums","content":"Open Enumerations By default, enum and intEnum shapes are considered to be closed and they are rendered as such. This means that it is expected that all possible values that can be in the enum are declared in the Smithy specification. However, there are certain times where you may require an open enumeration, meaning that values can be placed into it which are not declared in the Smithy specification. This can be useful for interoperability with APIs that you don't control, although often times a simple String or Integer shape will better suit a field where the values are not known beforehand. Open enumerations can be specified using the alloy#openEnum trait (docs here). use alloy#openEnum @openEnum enum Shape { SQUARE, CIRCLE } @openEnum intEnum IntShape { SQUARE = 1 CIRCLE = 2 } When the alloy#openEnum trait is present, it makes it so the enumeration is rendered in the generated code with an extra case, $Unknown. For Example: case object SQUARE extends Shape case object CIRCLE extends Shape final case class $Unknown(value: String) extends Shape Note that the leading $ is added onto the Unknown case to prevent potential collisions with actual enum values.","keywords":"","version":"Next"},{"title":"Packed inputs","type":0,"sectionRef":"#","url":"/smithy4s/docs/codegen/customisation/packed-inputs","content":"Packed inputs By default, Smithy4s generates methods the parameters of which map to the fields of the input structure of the corresponding operation. For instance : service PackedInputsService { version: &quot;1.0.0&quot; operations: [PackedInputOperation] } operation PackedInputOperation { input: PackedInput } structure PackedInput { @required a: String @required b: String } leads to something conceptually equivalent to : trait PackedInputServiceGen[F[_]] { def packedInputOperation(a: String, b: String): F[Unit] } It is however possible to annotate the service (or operation) definition with the smithy4s.meta#packedInputs trait, in order for the rendered method to contain a single parameter, typed with actual input case class of the operation. For instance : use smithy4s.meta#packedInputs @packedInputs service PackedInputsService { version: &quot;1.0.0&quot; operations: [PackedInputOperation] } will produce the following Scala code trait PackedInputServiceGen[F[_]] { def packedInputOperation(input: PackedInput): F[Unit] } ","keywords":"","version":"Next"},{"title":"Optics - Lenses and Prisms","type":0,"sectionRef":"#","url":"/smithy4s/docs/codegen/customisation/optics","content":"","keywords":"","version":"Next"},{"title":"Optics Usage​","type":1,"pageTitle":"Optics - Lenses and Prisms","url":"/smithy4s/docs/codegen/customisation/optics#optics-usage","content":"Below is an example of using the lenses that smithy4s generates. By default, smithy4s will generate lenses for all structure shapes in your input smithy model(s). import smithy4s.example._ val input = TestInput(&quot;test&quot;, TestBody(Some(&quot;test body&quot;))) // input: TestInput = TestInput( // pathParam = &quot;test&quot;, // body = TestBody(data = Some(value = &quot;test body&quot;)), // queryParam = None // ) val lens = TestInput.optics.body.andThen(TestBody.optics.data).some // lens: smithy4s.optics.Optional[TestInput, String] = smithy4s.optics.Optional$$anon$1@4f06ad6f val resultGet = lens.project(input) // resultGet: Option[String] = Some(value = &quot;test body&quot;) resultGet == Option(&quot;test body&quot;) // true // res1: Boolean = true // true val resultSet = lens.replace(&quot;new body&quot;)(input) // resultSet: TestInput = TestInput( // pathParam = &quot;test&quot;, // body = TestBody(data = Some(value = &quot;new body&quot;)), // queryParam = None // ) val updatedInput = TestInput(&quot;test&quot;, TestBody(Some(&quot;new body&quot;))) // updatedInput: TestInput = TestInput( // pathParam = &quot;test&quot;, // body = TestBody(data = Some(value = &quot;new body&quot;)), // queryParam = None // ) resultSet == updatedInput // true // res2: Boolean = true  You can also compose prisms with lenses (and vice-versa) as in the example below: import smithy4s.example._ val input = Podcast.Video(Some(&quot;Pod Title&quot;)) // input: Podcast.Video = Video( // title = Some(value = &quot;Pod Title&quot;), // url = None, // durationMillis = None // ) val prism = Podcast.optics.video.andThen(Podcast.Video.optics.title).some // prism: smithy4s.optics.Optional[Podcast, String] = smithy4s.optics.Optional$$anon$1@78e1f9c9 val result = prism.replace(&quot;New Pod Title&quot;)(input) // result: Podcast = Video( // title = Some(value = &quot;New Pod Title&quot;), // url = None, // durationMillis = None // ) Podcast.Video(Some(&quot;New Pod Title&quot;)) == result // true // res4: Boolean = true  Smithy4s also provides a value function on Prisms and Lenses that can be used to abstract over NewTypes (similar to what .some does for Option types): import smithy4s.example._ val input = GetCityInput(CityId(&quot;test&quot;)) // input: GetCityInput = GetCityInput(cityId = &quot;test&quot;) val cityName: smithy4s.optics.Lens[GetCityInput, String] = GetCityInput.optics.cityId.value // cityName: smithy4s.optics.Lens[GetCityInput, String] = smithy4s.optics.Lens$$anon$2@61d4d4ef val updated = cityName.replace(&quot;Fancy New Name&quot;)(input) // updated: GetCityInput = GetCityInput(cityId = &quot;Fancy New Name&quot;) val result = cityName.project(updated) // result: Option[String] = Some(value = &quot;Fancy New Name&quot;) Option(&quot;Fancy New Name&quot;) == result // true // res6: Boolean = true  ","version":"Next","tagName":"h2"},{"title":"Using 3rd Party Optics Libraries​","type":1,"pageTitle":"Optics - Lenses and Prisms","url":"/smithy4s/docs/codegen/customisation/optics#using-3rd-party-optics-libraries","content":"If you'd like to use a third party optics library for more functionality, you can accomplish this by adding an object with a few conversion functions. Here is an example using Monocle. object MonocleConversions { implicit def smithy4sToMonocleLens[S, A]( smithy4sLens: smithy4s.optics.Lens[S, A] ): monocle.Lens[S, A] = monocle.Lens[S, A](smithy4sLens.get)(smithy4sLens.replace) implicit def smithy4sToMonoclePrism[S, A]( smithy4sPrism: smithy4s.optics.Prism[S, A] ): monocle.Prism[S, A] = monocle.Prism(smithy4sPrism.project)(smithy4sPrism.inject) implicit def smithy4sToMonocleOptional[S, A]( smithy4sOptional: smithy4s.optics.Optional[S, A] ): monocle.Optional[S, A] = monocle.Optional(smithy4sOptional.project)(smithy4sOptional.replace) }  Then you can import MonocleConversions._ at the top of any file you need to seamlessly convert smithy4s optics over to Monocle ones. ","version":"Next","tagName":"h2"},{"title":"Non-Orphan Typeclass Instances","type":0,"sectionRef":"#","url":"/smithy4s/docs/codegen/customisation/typeclass","content":"","keywords":"","version":"Next"},{"title":"Setup Typeclass in Smithy​","type":1,"pageTitle":"Non-Orphan Typeclass Instances","url":"/smithy4s/docs/codegen/customisation/typeclass#setup-typeclass-in-smithy","content":"Here we will use the smithy4s.meta#typeclass trait to define a hash trait that represents the cats.Hash typeclass. use smithy4s.meta#typeclass @trait @typeclass(targetType: &quot;cats.Hash&quot;, interpreter: &quot;smithy4s.interopcats.SchemaVisitorHash&quot;) structure hash {}  We are specifying cats.hash as the targetType since that is the typeclass which this trait represents. We are then specifying smithy4s.interopcats.SchemaVisitorHash as the classpath which points to a CachedSchemaCompiler for the cats.Hash typeclass. ","version":"Next","tagName":"h2"},{"title":"Implement CachedSchemaCompiler​","type":1,"pageTitle":"Non-Orphan Typeclass Instances","url":"/smithy4s/docs/codegen/customisation/typeclass#implement-cachedschemacompiler","content":"Smithy4s has a concept called CachedSchemaCompiler which is an abstraction which we use here to interpret a smithy4s.Schema to produce an instance of a typeclass. Here is what this will look like: object SchemaVisitorHash extends CachedSchemaCompiler.Impl[Hash] { protected type Aux[A] = Hash[A] def fromSchema[A]( schema: Schema[A], cache: Cache ): Hash[A] = { schema.compile(new SchemaVisitorHash(cache)) } }  Here we are delegating to the SchemaVisitorHash which is doing the heavy lifting of interpreting the smithy4s.Schema. The CachedSchemaCompiler.Impl provides a Cache which we utilize to make sure we are not recompiling the same schema more than once. For more details on implementing a SchemaVisitor, you can check out the full cats.Hash schema compiler and visitor here. ","version":"Next","tagName":"h2"},{"title":"Use the hash typeclass trait​","type":1,"pageTitle":"Non-Orphan Typeclass Instances","url":"/smithy4s/docs/codegen/customisation/typeclass#use-the-hash-typeclass-trait","content":"Now we are ready to use the hash trait we defined above. @hash structure MovieTheater { name: String }  This tells smithy4s to generate an instance of the Hash typeclass in the companion object of the MovieTheater type and to use the CachedSchemaCompiler defined above for the implementation. The generated code will look like: case class MovieTheater(name: Option[String] = None) object MovieTheater extends ShapeTag.Companion[MovieTheater] { val id: ShapeId = ShapeId(&quot;smithy4s.example&quot;, &quot;MovieTheater&quot;) // ... implicit val schema: Schema[MovieTheater] = // ... implicit val movieTheaterHash: cats.Hash[MovieTheater] = SchemaVisitorHash.fromSchema(schema) }  ","version":"Next","tagName":"h2"},{"title":"Type refinements","type":0,"sectionRef":"#","url":"/smithy4s/docs/codegen/customisation/refinements","content":"Type refinements Type refinements provide a mechanism for using types that you control inside the code generated by smithy4s. Creating a refinement for use in your application starts with creating a custom smithy trait that represents the refinement. namespace test @trait(selector: &quot;string&quot;) structure emailFormat {} This trait can now be used on string shapes to indicate that they must match an email format. @emailFormat string Email Now we need to tell smithy4s that we want to represent shapes annotated with @emailFormat as a custom type that we define. Given a custom email type such as: // Note, we recommend using a newtype library over a regular case class in most cases // But this is shown to simplify the example case class Email(value: String) object Email { private def isValidEmail(value: String): Boolean = ??? def apply(value: String): Either[String, Email] = if (isValidEmail(value)) Right(new Email(value)) else Left(&quot;Email is not valid&quot;) } Next, we will need to provide a way for smithy4s to understand how to construct and deconstruct our Email type. We do this by defining an instance of a RefinementProvider. Note that the RefinementProvider we create MUST be implicit. // package myapp.types import smithy4s._ case class Email(value: String) object Email { private def isValidEmail(value: String): Boolean = ??? def apply(value: String): Either[String, Email] = if (isValidEmail(value)) Right(new Email(value)) else Left(&quot;Email is not valid&quot;) implicit val provider: RefinementProvider[EmailFormat, String, Email] = Refinement.drivenBy[EmailFormat]( Email.apply, // Tells smithy4s how to create an Email (or get an error message) given a string (e: Email) =&gt; e.value // Tells smithy4s how to get a string from an Email ) } info The EmailFormat type passed as a type parameter to Refinement.drivenBy is the type that smithy4s generated from our @emailFormat trait we defined in our smithy file earlier. Now, we just have one thing left to do: tell smithy4s where to find our custom Email type. We do this using a trait called smithy4s.meta#refinement. use smithy4s.meta#refinement apply test#emailFormat @refinement( targetType: &quot;myapp.types.Email&quot; ) Here we are applying the refinement trait to our emailFormat trait we defined earlier. We are providing the targetType which is our Email case class we defined. Smithy4s will now be able to update how it does code generation to reference our custom Email type. info If the provider was not in the companion object of our targetType, we would need to provide the providerImport to the refinement trait so that smithy4s would be able to find it. For example: use smithy4s.meta#refinement apply test#emailFormat @refinement( targetType: &quot;myapp.types.Email&quot;, providerImport: &quot;myapp.types.providers._&quot; ) Whether the provider is in the companion object or not, it must be implicit. Parameterised Types​ As of smithy4s version 0.17, you can now create refinements on types that take a generic type parameter. This can be accomplished by setting parameterised to true as seen below. @trait(selector: &quot;list&quot;) @refinement( targetType: &quot;smithy4s.example.refined.NonEmptyList&quot;, parameterised: true ) structure nonEmptyListFormat {} Following this, we now need to create our refinement provider as we did with the example above. In this case, we will use an implicit function so we can reference the generic type parameter A. This allows us to use the same implementation of NonEmptyList across lists containing any type. import smithy4s._ case class NonEmptyList[A] private (values: List[A]) object NonEmptyList { def apply[A](values: List[A]): Either[String, NonEmptyList[A]] = if (values.size &gt; 0) Right(new NonEmptyList(values)) else Left(&quot;List must not be empty.&quot;) implicit def provider[A]: RefinementProvider[NonEmptyListFormat, List[A], NonEmptyList[A]] = Refinement.drivenBy[NonEmptyListFormat]( NonEmptyList.apply[A], (b: NonEmptyList[A]) =&gt; b.values ) } Now we can apply our nonEmptyListFormat trait as follows: @nonEmptyListFormat list NonEmptyStrings { member: String } In the generated Scala code, this will render as a NonEmptyList[String] instead of a List[String]. Similarly, we can apply the nonEmptyListFormat trait to any list shape and it will render as a NonEmptyList. This works for all shapes that can be specified as list members including primitives, structures, collections, and even other refined types.","keywords":"","version":"Next"},{"title":"New types (and unwrapping)","type":0,"sectionRef":"#","url":"/smithy4s/docs/codegen/customisation/unwrapping","content":"New types (and unwrapping) By default, smithy4s will wrap all standalone primitive types in a Newtype. A standalone primitive type is one that is defined like the following: string Email // standalone primitive structure Test { email: Email other: String // not a standalone primitive } Given this example, smithy4s would generate something like the following: final case class Test(email: Email, other: String) This wrapping may be undesirable in some circumstances. As such, we've provided the smithy4s.meta#unwrap trait. This trait tells the smithy4s code generation to not wrap these types in a newtype when they are used. use smithy4s.meta#unwrap @unwrap string Email structure Test { email: Email other: String } This would now generate something like: final case class Test(email: String, other: String) This can be particularly useful when working with refinement types (see above for details on refinements). By default, any type that is refined will be generated inside of a newtype. If you don't want this, you can mark the type with the unwrap trait. @trait(selector: &quot;string&quot;) structure emailFormat {} @emailFormat @unwrap string Email info By default, smithy4s renders collection types as unwrapped EXCEPT when the collection has been refined. In this case, the collection will be rendered within a newtype by default. If you wish your refined collection be rendered unwrapped, you can accomplish this using the same @unwrap trait annotation on it.","keywords":"","version":"Next"},{"title":"Scala wildcard type arguments","type":0,"sectionRef":"#","url":"/smithy4s/docs/codegen/customisation/wildcard","content":"Scala wildcard type arguments Scala has a specific syntax for wildcard argument in types. In Scala 2, that was the underscore: _. But with Scala 3, this is changing. See the language reference page for more information. Smithy4s now has a way for you to control that, and the good thing is that you probably don't have to worry about it. If you're using Smithy4s via mill or sbt, then it's taken care of you. It can be overriden via the following keys: in mill, task: def smithy4sWildcardArgument = &quot;?&quot; // or &quot;_&quot;in sbt, setting: smithy4sWildcardArgument := &quot;?&quot; // or &quot;_&quot; If you are using Smithy4s via the CLI, then they way to utilize this feature is through your Smithy specifications. The simplest approach is to add a file with the following content to your CLI invocation: $version: &quot;2&quot; metadata smithy4sWildcardArgument = &quot;?&quot; // can also be `_` ","keywords":"","version":"Next"},{"title":"A Special Thanks To","type":0,"sectionRef":"#","url":"/smithy4s/docs/credits","content":"A Special Thanks To Yourkit​ YourKit supports open source projects with innovative and intelligent tools for monitoring and profiling JVM applications. YourKit is the creator of YourKit Java Profilerand YourKit YouMonitor","keywords":"","version":"Next"},{"title":"Default Values","type":0,"sectionRef":"#","url":"/smithy4s/docs/codegen/default-values","content":"","keywords":"","version":"Next"},{"title":"Null Default​","type":1,"pageTitle":"Default Values","url":"/smithy4s/docs/codegen/default-values#null-default","content":"When the smithy.api#default trait annotating a shape contains a null value, and the shape is not additionally annotated explicitly as nullable, Smithy4s will (where possible) assume a &quot;zero value&quot; as the default. For example: structure Test { @default // same thing as @default(null) one: String }  Here the default for the field one will be assumed to be an empty string (&quot;&quot;). Below is a table showing what all the zero values are for each different Smithy shape type: Smithy Type\tZero Valueblob\tArray.empty boolean\tfalse string\t&quot;&quot; byte\t0 short\t0 integer\t0 long\t0 float\t0 double\t0 bigInteger\t0 bigDecimal\t0 timestamp\t0 epoch (01 Jan 1970) document\tDocument.DNull enum\tN/A intEnum\tN/A list\tList.empty map\tMap.empty structure\tN/A union\tN/A service\tN/A operation\tN/A resource\tN/A Not every shape type has a corresponding zero value. For example, there is no reasonable zero value for a structure or a union type. As such, they will not have a zero value set even if they are marked with a null default trait. ","version":"Next","tagName":"h2"},{"title":"Service Product","type":0,"sectionRef":"#","url":"/smithy4s/docs/codegen/customisation/service-product","content":"","keywords":"","version":"Next"},{"title":"Static description of services​","type":1,"pageTitle":"Service Product","url":"/smithy4s/docs/codegen/customisation/service-product#static-description-of-services","content":"Implementation import smithy4s.kinds.PolyFunction5 type Describe[_, _, _, _, _] = String def descriptor[Alg[_[_, _, _, _, _]]](mirror: ServiceProduct.Mirror[Alg]): mirror.Prod[Describe] = mirror .serviceProduct .mapK5( mirror.serviceProduct.endpointsProduct, new PolyFunction5[mirror.serviceProduct.service.Endpoint, Describe] { override def apply[I, E, O, SI, SO]( fa: mirror.serviceProduct.service.Endpoint[I, E, O, SI, SO] ): Describe[I, E, O, SI, SO] = s&quot;def ${fa.name}(input: ${fa.input.shapeId.name}): ${fa.output.shapeId.name}&quot; }, )  // Usage val desc: String = descriptor(ExampleService).exampleOperation // desc: String = &quot;def ExampleOperation(input: ExampleOperationInput): ExampleOperationOutput&quot;  ","version":"Next","tagName":"h3"},{"title":"Non-linear input of operation​","type":1,"pageTitle":"Service Product","url":"/smithy4s/docs/codegen/customisation/service-product#non-linear-input-of-operation","content":"Implementation import smithy4s.ShapeId type Id[A] = A val impl: ExampleService[Id] = new ExampleService[Id] { override def exampleOperation(input: String): ExampleOperationOutput = ExampleOperationOutput( s&quot;Output for $input!&quot; ) } // impl: ExampleService[Id] = repl.MdocSession$MdocApp$$anon$2@326d8c05 type ListClient[I, _, O, _, _] = List[I] =&gt; List[O] def listClient[Alg[_[_, _, _, _, _]], Prod[_[_, _, _, _, _]]]( impl: smithy4s.kinds.FunctorAlgebra[Alg, Id] )( implicit sp: ServiceProduct.Aux[Prod, Alg] ): Prod[ListClient] = sp .mapK5( sp.endpointsProduct, new PolyFunction5[sp.service.Endpoint, ListClient] { private val interp = sp.service.toPolyFunction(impl) override def apply[I, E, O, SI, SO]( fa: sp.service.Endpoint[I, E, O, SI, SO] ): List[I] =&gt; List[O] = _.map(in =&gt; interp(fa.wrap(in))) }, )  listClient(impl)( /* implicit scope problem here - TODO */ ExampleService.serviceProduct) .exampleOperation( List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).map(ExampleOperationInput(_)) ) // res1: List[ExampleOperationOutput] = List( // ExampleOperationOutput(b = &quot;Output for a!&quot;), // ExampleOperationOutput(b = &quot;Output for b!&quot;), // ExampleOperationOutput(b = &quot;Output for c!&quot;) // )  ","version":"Next","tagName":"h3"},{"title":"Fluent service builder​","type":1,"pageTitle":"Service Product","url":"/smithy4s/docs/codegen/customisation/service-product#fluent-service-builder","content":"Implementation type ToList[_, _, O, _, _] = List[O] trait EndpointHandlerBuilder[I, E, O, SI, SO] { def apply(f: I =&gt; O): EndpointHandler } sealed trait EndpointHandler { type I_ type O_ def id: ShapeId def function: I_ =&gt; O_ } case class PartialBuilder[Alg[_[_, _, _, _, _]], Prod[_[_, _, _, _, _]]]( mirror: ServiceProduct.Mirror.Aux[Alg, Prod], handlers: List[EndpointHandler], ) { private val sp: ServiceProduct.Aux[Prod, Alg] = mirror.serviceProduct private val ehbProduct = sp .mapK5( sp.endpointsProduct, new PolyFunction5[sp.service.Endpoint, EndpointHandlerBuilder] { override def apply[I, E, O, SI, SO]( fa: sp.service.Endpoint[I, E, O, SI, SO] ): EndpointHandlerBuilder[I, E, O, SI, SO] = new EndpointHandlerBuilder[I, E, O, SI, SO] { override def apply(f: I =&gt; O): EndpointHandler = new EndpointHandler { type I_ = I type O_ = O override val id: ShapeId = fa.id override val function: I_ =&gt; O_ = f } } }, ) def build: Alg[ToList] = sp .service .algebra(new sp.service.EndpointCompiler[ToList] { override def apply[I, E, O, SI, SO]( fa: sp.service.Endpoint[I, E, O, SI, SO] ): I =&gt; List[O] = { val matchingHandlers = handlers .filter(_.id == fa.id) // A bit of type unsafety, to simplify things .map(_.function.asInstanceOf[I =&gt; O]) i =&gt; matchingHandlers.map(_.apply(i)) } }) def withHandler( op: Prod[EndpointHandlerBuilder] =&gt; EndpointHandler ): PartialBuilder[Alg, Prod] = copy(handlers = handlers :+ op(ehbProduct)) } def partialBuilder[Alg[_[_, _, _, _, _]]]( mirror: ServiceProduct.Mirror[Alg] ): PartialBuilder[Alg, mirror.Prod] = new PartialBuilder[Alg, mirror.Prod](mirror, handlers = Nil)  val listService: ExampleServiceGen[ToList] = partialBuilder(ExampleService) .withHandler(_.exampleOperation { (in: ExampleOperationInput) =&gt; ExampleOperationOutput(s&quot;First output for ${in.a}!&quot;) }) .withHandler(_.exampleOperation { (in: ExampleOperationInput) =&gt; ExampleOperationOutput(s&quot;Another output for ${in.a}!&quot;) }) .build // listService: ExampleServiceGen[ToList] = smithy4s.example.product.ExampleServiceOperation$Transformed@14e0e5a4 listService.exampleOperation(&quot;hello&quot;) // res2: ToList[ExampleOperationInput, Nothing, ExampleOperationOutput, Nothing, Nothing] = List( // ExampleOperationOutput(b = &quot;First output for hello!&quot;), // ExampleOperationOutput(b = &quot;Another output for hello!&quot;) // )  ","version":"Next","tagName":"h3"},{"title":"General design principles","type":0,"sectionRef":"#","url":"/smithy4s/docs/design/design","content":"General design principles Before we dive in to the design elements, it is important to state that Smithy4s is designed with the following constraints : optimised for number of usecases: Smithy4s is not (just) an http/json library, it can/could be used for a great many things, such as AWS SDKs, CLIs, UIs, etc. Therefore, following the protocol-agnostic nature of smithy, the code generated by Smithy4s is not biased towards any protocol or serialisation mechanism, nor any runtime or Scala version.optimised for correctness over compatibility: there is strictly no guarantee made regarding backward compatibility of the generated code when users evolve their smithy schemas. Therefore, users are expected to regenerate the code at use-site, instead of relying on artifacts that would contain the generated code... However, users do get idiomatic Scala code, including case classes / sealed traits (which are notoriously hard to evolve in binary compatible ways), and this generated code correctly reflects the smithy specifications.decoupled from third-party libraries: the generated code depends only on smithy4s-core for compilation, which does not pull third-party dependencies (not even a general purpose libraries that the maintainers love, like cats) These constraints may sound counter-intuitive, obtuse, even alien. The internals of this library are not beginner friendly. They rely on advanced features of the Scala compiler that may unfortunately scare away newcomers interested in contributing. If you're not discouraged yet, do not hesitate to ask questions using github discussions, we will do our best to answer them!","keywords":"","version":"Next"},{"title":"Unions and sealed traits","type":0,"sectionRef":"#","url":"/smithy4s/docs/codegen/unions","content":"","keywords":"","version":"Next"},{"title":"Flattening of structure members​","type":1,"pageTitle":"Unions and sealed traits","url":"/smithy4s/docs/codegen/unions#flattening-of-structure-members","content":"Under certain conditions, Smithy4s offers a mechanism to &quot;flatten&quot; structure members directly as a member of the sealed trait. Head over to the page explaining code-gen customisation for a detailed explanation. ","version":"Next","tagName":"h3"},{"title":"Regarding JSON encoding​","type":1,"pageTitle":"Unions and sealed traits","url":"/smithy4s/docs/codegen/unions#regarding-json-encoding","content":"Smithy4s does not rely on the classic automated derivation mechanisms to determine how unions should be encoded in JSON. Rather, the Smithy models dictates the encoding. Indeed, there are multiple ways to encode unions in JSON. By default, the specification of the Smithy language hints that the tagged-union encoding should be used. This is arguably the best encoding for unions, as it works with members of any type (not just structures), and does not require backtracking during parsing, which makes it more efficient. However, Smithy4s provides support for two additional encodings: discriminated and untagged, which users can opt-in via the alloy#discriminated and alloy#untagged trait, respectively. These are mostly offered as a way to retrofit existing APIs in Smithy. Tagged union​ This is the default behaviour, and happens to visually match how Smithy unions are declared. In this encoding, the union is encoded as a JSON object with a single key-value pair, the key signalling which alternative has been encoded. union Tagged { first: String second: IntWrapper } structure IntWrapper { int: Integer }  The following instances of Tagged Tagged.FirstCase(&quot;smithy4s&quot;) Tagged.SecondCase(IntWrapper(42)))  are encoded as such : { &quot;first&quot;: &quot;smithy4s&quot; } { &quot;second&quot;: { &quot;int&quot;: 42 } }  Untagged union​ Untagged unions are supported via an annotation: @untagged. Despite the smaller payload size this encoding produces, it is arguably the worst way of encoding unions, as it may require backtracking multiple times on the parsing side. Use this carefully, preferably only when you need to retrofit an existing API into Smithy use alloy#untagged @untagged union Untagged { first: String second: IntWrapper } structure IntWrapper { int: Integer }  The following instances of Untagged Untagged.FirstCase(&quot;smithy4s&quot;) Untagged.SecondCase(Two(42)))  are encoded as such : &quot;smithy4s&quot; { &quot;int&quot;: 42 }  Discriminated union​ Discriminated union are supported via an annotation: @discriminated(&quot;tpe&quot;), and work only when all members of the union are structures. In this encoding, the discriminator is inlined as a JSON field within JSON object resulting from the encoding of the member. Despite the JSON payload exhibiting less nesting than in the tagged union encoding, this encoding often leads to bigger payloads, and requires backtracking once during parsing. use alloy#discriminated @discriminated(&quot;tpe&quot;) union Discriminated { first: StringWrapper second: IntWrapper } structure StringWrapper { string: String } structure IntWrapper { int: Integer }  The following instances of Discriminated Discriminated.FirstCase(StringWrapper(&quot;smithy4s&quot;)) Discriminated.SecondCase(IntWrapper(42)))  are encoded as such { &quot;tpe&quot;: &quot;first&quot;, &quot;string&quot;: &quot;smithy4s&quot; } { &quot;tpe&quot;: &quot;second&quot;, &quot;int&quot;: 42 }  ","version":"Next","tagName":"h3"},{"title":"Union Projections and Visitors​","type":1,"pageTitle":"Unions and sealed traits","url":"/smithy4s/docs/codegen/unions#union-projections-and-visitors","content":"In order to make working with unions more ergonomic, smithy4s provides projection functions and generates visitors for all unions. Projection Functions​ Here we will see what a projection function looks like using a simple union example of Pet. sealed trait Pet { object project { def dog: Option[Dog] def cat: Option[Cat] } } object Pet { case class DogCase(dog: Dog) extends Pet case class CatCase(cat: Cat) extends Pet }  These functions can then be used as follows: val myPet: Pet = Pet.DogCase(Dog(name = &quot;Spot&quot;)) myPet.project.dog // Some(Dog(name = &quot;Spot&quot;)) myPet.project.cat // None  These projection functions make it so you can work with specific union alternatives without needing to do any pattern matching. Visitors​ Using the same pet example, we will now see what the visitors look like that smithy4s generates. sealed trait Pet { def accept[A](visitor: Pet.Visitor[A]): A = // ... } object Pet { case class DogCase(dog: Dog) extends Pet case class CatCase(cat: Cat) extends Pet trait Visitor[A] { def dog(dog: Dog): A def cat(cat: Cat): A } }  Similar to the projection functions, the visitor allows us to handle the alternatives without a pattern match. For example: val myPet: Pet = Pet.DogCase(Dog(name = &quot;Spot&quot;)) val visitor = new Pet.Visitor[String] { def dog(dog: Dog): String = s&quot;Dog named ${dog.name}&quot; def cat(cat: Cat): String = s&quot;Cat named ${cat.name}&quot; } myPet.accept(visitor) // &quot;Dog named Spot&quot;  You can also implement a Visitor using Visitor.Default to provide a default value to be used for cases that you don't explicitly implement. For example: val myPet: Pet = Pet.DogCase(Dog(name = &quot;Spot&quot;)) val visitor = new Pet.Visitor.Default[String] { def default: String = &quot;default value&quot; def cat(cat: Cat): String = s&quot;Cat named ${cat.name}&quot; } myPet.accept(visitor) // &quot;default value&quot;  ","version":"Next","tagName":"h2"},{"title":"Services and endpoints","type":0,"sectionRef":"#","url":"/smithy4s/docs/design/services","content":"","keywords":"","version":"Next"},{"title":"The duality of final and initial algebras​","type":1,"pageTitle":"Services and endpoints","url":"/smithy4s/docs/design/services#the-duality-of-final-and-initial-algebras","content":"Before we dive into the core of the solution, one notion that is drastically helpful is the duality between finally-encoded algebras and initially-encoded algebras. Finally-encoded algebras are object-oriented encodings of a set of operations, just like above: operations are represented as methods in an interface. Interpretation of expressions written in terms of these methods does not involve any runtime transformation from one context to another: the method call is merely executed. In other words, when they are executed, expressions coming from finally-encoded algebras are already in their &quot;final form&quot;. Conversely, initially-encoded algebras represent expressions as data, implying that interpretation involves a transformation of this data into lower level method calls. However, data has the quality of being a first class construct in programming languages, meaning you can pass it around and use it as parameter to functions. This allows for the unification of code-paths, as the differences between some aspects of a bit of logic can be absorbed by the data and handled later on. Finally-encoded KVStore algebra : trait KVStore[Context[_]]{ def put(key: String, value: String): Context[Unit] def get(key: String) : Context[Option[String]] def delete(key: String) : Context[Unit] }  Initially-encoded KVStore algebra : sealed trait KVStoreOp[Output] object KVStoreOp { case class Put(key: String, value: String) extends KVStore[Unit] case class Get(key: String) extends KVStore[Option[String]] case class Delete(key: String) extends KVStore[Unit] }  These two encodings contain a similar amount of information. It is nearly-trivial to go from a KVstore[Context] instance to a KVStoreOp ~&gt; Context polymorphic function (natural-transformation), and vice versa: trait ~&gt;[F[_], G[_]]{ def apply[A](fa: F[A]): G[A] } def asNaturalTransformation[Context[_]](impl: KVStore[Context]) = new (KVStoreOp ~&gt; Context){ def apply[A](fa: KVStoreOp[A]): Context[A] = fa match { case KVStoreOp.Put(key, value) =&gt; impl.put(key, value) case KVStoreOp.Get(key) =&gt; impl.get(key) case KVStoreOp.Delete(key) =&gt; impl.delete(key) } } def fromNaturalTransformation[Context[_]](run: KVStoreOp ~&gt; Context) = new KVStore[Context]{ def put(key: String, value: String) = run(KVStoreOp.Put(key, value)) def get(key: String) = run(KVStoreOp.Get(key)) def delete(key: String) = run(KVStoreOp.Delete(key)) }  This duality is heavily used by Smithy4s: finally-encoded interfaces are generally more natural to Scala developers, and are better supported in editors (autocompletion, etc). But from an implementation's perspective, the initial, data-based encoding is really interesting, because operations are reified as data-types that can be associated with instances of generic type-classes: it is possible to abstract over data, it is not possible to abstract over method calls. ","version":"Next","tagName":"h2"},{"title":"A detour around kinds​","type":1,"pageTitle":"Services and endpoints","url":"/smithy4s/docs/design/services#a-detour-around-kinds","content":"The methods generated by Smithy4s are conceptually similar to the methods expressed in the example above, except that the output types are significantly more verbose. trait Interface[Context[_, _, _, _, _,]]{ def operation1(a: A, b: B): Context[Input, Error, Output, StreamedInput, StreamedOutput] }  Let's address this awkwardness right away, by explaining the rationale behind this seemingly humongous signature : Input​ It's the input type of an operation. Typically, a case class that holds fields matching the method parameters. We keep track of it in the return type for several reasons: In the internal logic of Smithy4s, It prevents having to prematurely shoe-horn kinds into other kinds by means of injection/projection, which helps both implementor and compiler alikeIt will come in handy for the implementation of some pagination-aware interpreters, as pagination typically works by performing a modification of the previous input in order to get the next batch (page) of results. This implies that the input (and therefore its type) must be tracked across several requests resulting from a single method call. Error​ The execution of an operation can result in errors. The Smithy language allows for tying a list of errors to operations. When generating the associated code, Smithy4s synthesize a union. This allows the coproduct of errors associated to an operation to be represented as a bona fide Scala type, which we can abstract over via some type-class instance. This is also very useful for the writing of bi-functor interpreters, for users that are interested in this kind of UX. Output​ No surprise there: this is the data resulting from the run of the operation. StreamedInput, StreamedOutput​ Smithy supports the concept of Streaming. It is communicated as a trait that annotates a single field of the input shape or/and output shape of an operation. Scala does not have a &quot;standard&quot; way of expressing streaming semantics. Moreover, streaming constructs in Scala are heavily context dependant. It is therefore impossible for us to incorporate the concept of &quot;streaming&quot; to our Schema construct as it is meant to be context-free and third-party-free. To get some intuition for why that is: say we want to express streaming using fs2. If we naively generate a case class that has one of its fields annotated with @streaming, it means that the the field is of type fs2.Stream[F, A], which means that we either need to make a decision on what the F is, which is not okay for obvious reasons, or we need to propagate the F[_] type parameter upward to the case class. Now our Schema value, which accompanies the case-class, also have to carry the F ... this propagates throughout the whole codebase. We deemed that not acceptable. Rather than polluting all layers of abstraction, we decided to just have the concept of operation be impacted and hold the streamed type in a separate type parameter. This allows for interpreters from various ecosystem to emerge. It also has the quality of allowing users to access the unary component of outputs (ie, data that is communicated in the headers of HTTP responses) without necessarily allocating resources to consume the streamed component of the output. NB: at the time of writing this, Smithy4s does not have any streaming-aware interpreter implemented. But streaming is such a fundamental notion in remote interactions, and we had to devise a plan to ensure that third parties could decide to implement interpreters without waiting. ","version":"Next","tagName":"h3"},{"title":"Transformation​","type":1,"pageTitle":"Services and endpoints","url":"/smithy4s/docs/design/services#transformation","content":"Because of the complex kinds we're dealing with, we codify a polymorphic function (natural-transformation), called smithy4s.kinds.PolyFunction5 that allows us to work at this level : trait PolyFunction5[F[_, _, _, _, _], G[_, _, _, _, _]] { def apply[I, E, O, SI, SO](fa: F[I, E, O, SI, SO]): G[I, E, O, SI, SO] }  This is a mouthful, but conceptually, it's exactly the same as our good old polymorphic function typically aliased to ~&gt;. ","version":"Next","tagName":"h3"},{"title":"Codifying the duality between initial and final algebras​","type":1,"pageTitle":"Services and endpoints","url":"/smithy4s/docs/design/services#codifying-the-duality-between-initial-and-final-algebras","content":"What we want users to manipulate is the final-encoded version of a service: a good-old object-oriented interface that has decent editor support. But we need the initial-encoded version to implement interpreters in a generic fashion. So we codify the duality to allow for switching from one to the other via an abstraction called Smithy4s.Service, which is the entry point to all interpreters. trait Service[Final[_[_, _, _, _, _]]] { type Operation[_, _, _, _, _] def toPolyFunction[F[_, _, _, _, _,]](alg: Final[F]): PolyFunction5[Operation, F] def fromPolyFunction[F[_, _, _, _, _]](polyFunction: PolyFunction5[Operation, F]): Final[F] // ... }  Implementations of such interfaces are typically code-generated. This implies that any smithy Service shape gets translated as a finally-encoded interface, but also as an initially-encoded GADT ","version":"Next","tagName":"h3"},{"title":"The high-level philosophy of Smithy4s​","type":1,"pageTitle":"Services and endpoints","url":"/smithy4s/docs/design/services#the-high-level-philosophy-of-smithy4s","content":"The goal of Smithy4s is to allow users to derive client stubs and routers in various protocols, by running the generated code (or instances of generated interfaces) in some one-liner functions. To that end, Smithy4s surfaces a number of abstractions (such as smithy4s.schema.Schema) that allow for the implementation of (very) polymorphic interpreters. These interpreters operate on the generated code, which reflects what the user defines in their smithy Specs. The abstractions used by interpreters contain all the elements that allow for turning a high-level method call (from an interface generated by Smithy4s) into a low level request of some sort, and then transform a low level response into the output of the method call. ","version":"Next","tagName":"h2"},{"title":"Logical flow: client-side​","type":1,"pageTitle":"Services and endpoints","url":"/smithy4s/docs/design/services#logical-flow-client-side","content":"Conceptually, to derive a high-level client that uses some sort of Request =&gt; Response protocol, the implementation has to follow a sequence of steps: Assuming this method call: kvstore.get(&quot;key&quot;)turning the method call into a piece of data: KVStoreOp.Get(&quot;key&quot;) using the initially-encoded dual of the KVStore interfaceRetrieving the Smithy4s Schemas (input and output) associated to the Get operationCompiling the schema associated to the input of the Get operation into some encoding function: GetInput =&gt; RequestRunning the request through a low-level Request =&gt; Response function (like an HTTP client)Running Get into some function that gives us its GetInput representationCompiling the schema associated to the output (GetOutput ~= Option[String]) of the Get operation into some decoding function Response =&gt; Output So we get kvstore.get =&gt; KVStoreOp.Get =&gt; GetInput =&gt; Request =&gt; Response =&gt; GetOutput, which gives us the full data flow, client side. ","version":"Next","tagName":"h3"},{"title":"Logical flow: server-side​","type":1,"pageTitle":"Services and endpoints","url":"/smithy4s/docs/design/services#logical-flow-server-side","content":"The server side is different in that we want to derive the Request =&gt; Response function from an instance of our interface (KVStore). The goal is to mechanically translate a request into a method call, and a method's output into a response. The sequence: From a given Request, find the corresponding operation Op (for instance, by means of HTTP path). Let's assume it's the get operation,Retrieve the Smithy4s Schemas (input and output) associated to the operation (KVStoreOp.Get)Compile a Request =&gt; GetInput decoding function, and run the Request through itFrom GetInput, recreate the KVStoreOp.Get instanceFrom KVStoreOp.Get, use the final-encoded dual of KVStoreOp to call the KVStore#get method (implemented by the user). This gets us an GetOutputCompile a GetOutput =&gt; Response encoding function from the schemas, and run the output through it So we get Request =&gt; KVStoreOp.GetInput =&gt; KVStoreOp.Get =&gt; kvstore.get =&gt; GetOutput =&gt; Response, which gives us the full data flow, service side. Both the service-side and client-side logical flows guide the design of the abstractions that are exposed by Smithy4s. ","version":"Next","tagName":"h3"},{"title":"A note about efficiency​","type":1,"pageTitle":"Services and endpoints","url":"/smithy4s/docs/design/services#a-note-about-efficiency","content":"The flows described above are merely conceptual, and do not account for the optimisations involved to ensure that schemas are not recompiled into codecs on a per-request basis (which would greatly impact performance). Interpreters provided by Smithy4s (HTTP and co) are written to ensure that all compilation is performed ahead of receiving requests, by means of preliminary computations and caching. ","version":"Next","tagName":"h3"},{"title":"The Endpoint abstraction​","type":1,"pageTitle":"Services and endpoints","url":"/smithy4s/docs/design/services#the-endpoint-abstraction","content":"The smithy4s.Endpoint abstraction ties a specific operation to the various schemas that are tied to it. trait Endpoint[Op[_, _, _, _, _], I, E, O, SI, SO] { def schema: OperationSchema[I, E, O, SI, SO] def wrap(input: I): Op[I, E, O, SI, SO] }  where smithy4s.schema.OperationSchema is a product of all schemas involved in an specific operation. final case class OperationSchema[I, E, O, SI, SO]( id: ShapeId, hints: Hints, input: Schema[I], error: Option[ErrorSchema[E]], output: Schema[O], streamedInput: Option[StreamingSchema[SI]], streamedOutput: Option[StreamingSchema[SO]] ) {  Endpoints are not type-classes. Instead, an Endpoint instance is provided by the companion object of each member of the GADT forming the initial-encoding of the service interface. So, going back to our KVStore, the corresponding sealed-trait would look like this : sealed trait KVStoreOp[Input, Error, Output, StreamedInput, StreamedOutput]  and the put operation would look like : case class Put(input: PutRequest) extends KVStoreOp[PutRequest, PutError, PutResult, Nothing, Nothing] object Put extends Endpoint[KVStoreOp, PutRequest, PutError, PutResult, Nothing, Nothing] { val input = PutRequest.input val output = PutRequest.schema val streamedInput = SteamingSchema.nothing val streamedOutput = StreamingSchema.nothing val errorable: Option[Errorable[PutResult]] = this // ... val schema: OperationSchema[PutRequest, PutError, PutResult, Nothing, Nothing] = Schema.operation(ShapeId(&quot;namespace&quot;, &quot;Put&quot;)) .withInput(PutRequest.schema) .withError(PutError.errorSchema) .withOutput(PutResult.schema) def wrap(input: PutRequest) = Put(input) }  ","version":"Next","tagName":"h2"},{"title":"A note on errors​","type":1,"pageTitle":"Services and endpoints","url":"/smithy4s/docs/design/services#a-note-on-errors","content":"As stated previously, Smithy4s generates a coproduct type for each operation, where the members of the coproduct point to the various errors listed in the smithy operation shape. Additionally, each structure annotated with @error in smithy is rendered as a case-class that extends Throwable, because Throwables are the de-facto standard of doing error handling on the JVM. Even libraries that use Either to perform error handling often represent the left-hand-side of the Either as some throwable type, to facilitate the absorption of errors into the error-channels of monadic constructs (IO.raiseError, etc) As a result, it is important for Smithy4s to expose functions that generically enable the filtering of throwables against the Error type parameter of an operation, so that interpreters can intercept errors and apply the correct encoding (dictated via Schema) before communicating them back to the caller over the wire. Conversely, it is important to expose a function that allows to go from the generic Error type parameter to Throwable, so that errors received via low-level communication channels can be turned into Throwable at the client call site, in order to populate the relevant error channel when exposing mono-functor semantics. Therefore, when a smithy operation has errors defined, the corresponding smithy4s.schema.OperationSchema references a smithy4s.schema.ErrorSchema, which looks like this : case class ErrorSchema[E] private[smithy4s] ( schema: Schema[E], liftError: Throwable =&gt; Option[E], unliftError: E =&gt; Throwable )  ","version":"Next","tagName":"h3"},{"title":"Services and endpoints​","type":1,"pageTitle":"Services and endpoints","url":"/smithy4s/docs/design/services#services-and-endpoints","content":"In order to implement any server-side interpreters, it is required to have a list of endpoints. That list is used to implement some matching logic based on the shapeId and/or the hints associated to the endpoints, in order to deterministically decide where to route a low level Request to a specific Endpoint instance. For instance, smithy provides a @http trait out of the box that can annotate operations : service KVStore { operations: [Get, Put] } @http(method: &quot;GET&quot;, uri: &quot;/resource/${key}, code: 200) operation Get { input: GetInput output: GetOutput } structure GetInput { @httpLabel key: String } structure GetOutput { value: String } @http(method: &quot;PUT&quot;, uri: &quot;/resource/${key}, code: 200) operation Put { } structure PutInput { @httpLabel key: String, @httpPayload value: String }  Each @http occurrence get translated to a scala value in the Hints associated to the corresponding endpoint. On server-side, having a list of all the endpoints associated to a service allows for creating a routing logic that dispatches an HTTP Request to the correct endpoint.On client-side, a method call to a service stub gets translated to an instance of the corresponding GADT member. From there, we have to retrieve the schemas associated to the member in question. Additionally, we need to extract the input value out of the member, to run it through an encoder derived from the the associated Schema. Therefore, the Service abstraction needs to be enriched with the following methods : trait Service[Final[_[_, _, _, _, _]]] { type Initial[_, _, _, _, _] // ... // useful for server-side def endpoints: IndexedSeq[Endpoint[Initial, _, _, _, _, _]] // useful for client-side // provides the index of the endpoint associated to the operation def ordinal[I, E, O, SI, SO](op: Initial[I, E, O, SI, SO]): Int // extracts the input value out of a reified operation def input[I, E, O, SI, SO](op: Operation[I, E, O, SI, SO]): I }  ","version":"Next","tagName":"h2"},{"title":"Conclusion and complete interfaces​","type":1,"pageTitle":"Services and endpoints","url":"/smithy4s/docs/design/services#conclusion-and-complete-interfaces","content":"Here are links to the complete interfaces discussed in this chapter. ServiceEndpoint ","version":"Next","tagName":"h2"},{"title":"Datatypes and schemas","type":0,"sectionRef":"#","url":"/smithy4s/docs/design/schemas","content":"","keywords":"","version":"Next"},{"title":"The Schema GADT​","type":1,"pageTitle":"Datatypes and schemas","url":"/smithy4s/docs/design/schemas#the-schema-gadt","content":"Each datatype generated by Smithy4s is accompanied by a schema value in its companion object, which contains an expression of type smithy4s.schema.Schema that captures everything needed to deconstruct/reconstruct instances of the datatype. smithy4s.schema.Schema is a Generalised Algebraic Datatype (or GADT for short) that can be used to precisely reference all the information needed to traverse datatypes that can be expressed in Smithy. It is a bit like JVM reflection, except that it exposes higher-level information about the datatypes. It achieves this by exposing building blocks that accurately reflect what is possible to express in the Smithy language. These building blocks form a metamodel: a model for models. And, unlike JVM reflection, using schemas is type-safe. The Schema type reflects the various ways of constructing datatypes in Smithy. It is encoded as a sealed trait, the members of which capture the following aspects of the Smithy language: PrimitivesListsMapsEnumerationsStructuresUnions For a Scala type called Foo, formulating a Schema[Foo] is equivalent to exhaustively capturing the information needed for the serialisation and deserialisation of Foo in any format (JSON, XML, ...). Indeed, for any Codec[_] construct provided by third-party libraries, it is possible to write a generic def compile(schema: Schema[A]): Codec[A] function that produces the Codec for A based on the information held by the Schema. Why do things this way? Why not just render Codec during code generation? The reason is that we want for the generated code to be completely decoupled from any serialisation format or library, and for the user to have the ability to wire that generated code in different ways, without having to change anything in the build. Moreover, this approach has proven that it allows for a bounded investment for adding interop with various libraries, and offers really good testability. ","version":"Next","tagName":"h2"},{"title":"Hints​","type":1,"pageTitle":"Datatypes and schemas","url":"/smithy4s/docs/design/schemas#hints","content":"In Smithy, all shapes (and members of composite shapes) can be annotated with traits. Smithy4s generically translates these annotations to instances of the corresponding generated classes, which means that Smithy4s supports generating user defined traits that it has zero knowledge of. So if you have the following Smithy description: namespace example @trait structure metadata { @required description: String } @metadata(description: &quot;This is my own integer shape&quot;) integer MyInt  When processing this Smithy model, Smithy4s renders a case class Metadata(description: String), with an associated ShapeTag[Metadata] instance, and the following expression in the companion object of MyInt: val hints = Hints( Metadata(&quot;this is my own integer shape&quot;) )  The smithy4s.Hints type is a polymorphic map that can hold shapes, keyed by ShapeTag. A ShapeTag is a uniquely identified tag that uses referential equality. Every schema can hold a Hints instance, which means that in addition to the datatype structures, Schemas also offer an accurate reflection of the trait values that annotate shapes in the smithy models. Smithy4s uses these hints to implement interpreters. For instance, the smithy.api#jsonName smithy trait translates to a smithy.api.JsonName Scala type, that we can query from a Hints instance when implementing a Schema ~&gt; JsonCodec transformation. This allows to give users a little customisability in the json serialisation of their datatypes. ","version":"Next","tagName":"h3"},{"title":"Structures​","type":1,"pageTitle":"Datatypes and schemas","url":"/smithy4s/docs/design/schemas#structures","content":"A structure, also referred to as product, or record, is a construct that groups several values together. Typically, it translates naturally to a case class. namespace example structure Foo { @required a: Integer @length(min: 1) b: String }  ...and the associated, generated Scala code: package example import smithy4s.schema.Schema._ case class Foo(a: Int, b: Option[String] = None) object Foo extends smithy4s.ShapeTag.Companion[Foo] { val id: smithy4s.ShapeId = smithy4s.ShapeId(&quot;example&quot;, &quot;Foo&quot;) implicit val schema: smithy4s.Schema[Foo] = struct( int.required[Foo](&quot;a&quot;, _.a), string.optional[Foo](&quot;b&quot;, _.b).addHints(smithy.api.Length(Some(1), None)) ){ Foo.apply }.withId(id) }  As you can see, the Smithy structure translates quite naturally to a Scala case class. Every member of the structure that does not have either the @required trait or a default value specified is rendered as an optional value defaulting to None (by default, smithy4s sorts the fields before rendering the case class so that the required ones appear before the optional ones. That is a pragmatic decision that tends to improve UX for users.) Indeed, for each field, there is an associated reference to a schema (int, string, ...), a string label, and a lambda calling the case class accessor that allows the retrieval of the associated field value. Additionally, the constructor of the case class is also referenced in the Schema. Typically, the accessors are needed for encoding the data, which involves destructuring it to access its individual components. The labels are there to cater to serialisation mechanisms like JSON or XML, where sub-components of a piece of data are labelled and nested under a larger block. Conversely, the constructor is used for deserialisation, which involves reconstructing the data after all of its component values have been successfully deserialised. Another detail is the presence of the addHints call on field labelled with b. This is due to the presence of the length trait (from the smithy.api namespace, aka the prelude) on the corresponding b member of the smithy Foo shape. Note related to optional and required​ You may have noticed the required and optional methods, which create Field instances from Schemas, in order to pass them to structures. Since 0.18, the concept of Option in Smithy4s is backed by a OptionSchema member of the Schema GADT. Having Option as a first-class citizen has some advantages, as it allows to support sparse collections. The downside is that this allows to create schemas (and therefore codecs) that do not abide by round-tripping properties. Indeed, once data is on the wire, it's often impossible to distinguish Option[Option[Option[Int]] ] from Option[Int]. If you need to distinguish between presence of a null value and absence of a value, Smithy4s provides an additional Nullable type in order to allow an extra level of nesting. ","version":"Next","tagName":"h3"},{"title":"Unions​","type":1,"pageTitle":"Datatypes and schemas","url":"/smithy4s/docs/design/schemas#unions","content":"Union, also referred to as coproduct, or sum type, is a construct that expresses sealed polymorphism. It is the dual of a structure: when structures express that you have A AND B, unions express that you can have A OR B. The way this is expressed in Smithy looks like this: namespace example union Bar { a: Integer b: String }  This hints at the default serialisation that AWS has intended to use on unions expressed in smithy, namely tagged unions. Indeed, the AWS json-centric protocols specifies that shapes like these should be serialised in objects with a single key/value entry, where the key receives the value of the tag. For instance, { &quot;a&quot;: 1 } or { &quot;b&quot;: &quot;two&quot; }. There are some very relevant technical reasons for it, but this way of encoding unions/co-products in JSON is arguably the best. It may also be familiar to Circe users as it's the default encoding of co-products in circe-generic. Regarding the Scala code rendered by Smithy4s for the above Smithy specification, it looks like this: package example import smithy4s.schema.Schema._ sealed trait Bar extends scala.Product with scala.Serializable object Bar extends smithy4s.ShapeTag.Companion[Bar] { val id: smithy4s.ShapeId = smithy4s.ShapeId(&quot;foobar&quot;, &quot;Bar&quot;) case class ACase(a: Int) extends Bar case class BCase(b: String) extends Bar object ACase { val hints: smithy4s.Hints = smithy4s.Hints.empty val schema: smithy4s.Schema[ACase] = bijection(int.addHints(hints), ACase(_), _.a) val alt = schema.oneOf[Bar](&quot;a&quot;) } object BCase { val hints: smithy4s.Hints = smithy4s.Hints.empty val schema: smithy4s.Schema[BCase] = bijection(string.addHints(hints), BCase(_), _.b) val alt = schema.oneOf[Bar](&quot;b&quot;) } implicit val schema: smithy4s.Schema[Bar] = union( ACase.alt, BCase.alt, ){ case _: ACase =&gt; 0 case _: BCase =&gt; 1 }.withId(id) }  The union is rendered as an ADT (sealed trait), the members of which are single-value case classes wrapping values of the types referenced by the union member. The Case suffix is added as a way to reduce risk of collision between the generated code and other types (especially the types being wrapped). Each ADT member is accompanied by its own schema, which is not provided implicitly, in an effort to retain coherence in the type-class instances, and avoid the situation where you'd have different behaviours during serialisation based on whether you've up-casted a member to the ADT. Additionally, the companion objects of each ADT members contain an alt value (for &quot;alternative&quot;), which is the union's equivalent to the structure's field. Much like a field, an alt contains a label, and can carry hints. But unlike a field, which contains an accessor, the alt contains the function to &quot;inject&quot; (up-cast) the member into the union. This is useful for de-serialisation, when, after successfully de-serialising a member of a union, you need to inject it into the ADT to return the expected type. As for the union's schema, it is somewhat similar to the structure's, in that it references all its alternatives. But instead of a structure's constructor, we have a dispatch function instead, which contains a pattern match against all the possible members, and dispatches the &quot;down-casted&quot; value to its corresponding ordinal, allowing to recover the corresponding alternative. This is useful for serialisation, when the behaviour of the alternatives can only be applied to values of the corresponding type: &quot;if my ADT is an A, then I serialise the A, and add a discriminating tag to the serialised A&quot;. ","version":"Next","tagName":"h3"},{"title":"Named simple shapes​","type":1,"pageTitle":"Datatypes and schemas","url":"/smithy4s/docs/design/schemas#named-simple-shapes","content":"Smithy allows for the creation of named shapes that reference &quot;primitive types&quot;: namespace example integer MyInt  Smithy4s translates this to a Scala newtype: a zero-overhead wrapper for the underling type (in this case, Int): package example object MyInt extends Newtype[Int] { val id: smithy4s.ShapeId = smithy4s.ShapeId(&quot;foobar&quot;, &quot;MyInt&quot;) val hints: smithy4s.Hints = smithy4s.Hints.empty val underlyingSchema: smithy4s.Schema[Int] = int.withId(id).addHints(hints) implicit val schema: smithy4s.Schema[MyInt] = bijection(underlyingSchema, MyInt(_), (_: MyInt).value) }  A MyInt type alias, pointing to the MyInt.Type type member, is rendered in the example package object, which makes it possible to write such code: val myInt: MyInt = MyInt(1) // val int: Int = myInt // doesn't compile because MyInt is not an Int at compile time. val int: Int = myInt.value  You may have noticed that the schema value is using bijection. Additionally to the GADT members stated previously, Schema also has a BijectionSchema member, which allows to apply bidirectional transformation on other Schemas. This is useful for the case of newtypes: if we are able to derive a codec that can encode and decode Int, it should be possible to derive a codec that encodes and decodes MyInt. ","version":"Next","tagName":"h3"},{"title":"Collections​","type":1,"pageTitle":"Datatypes and schemas","url":"/smithy4s/docs/design/schemas#collections","content":"Smithy supports two types of collections out of the box : listmap NB: the &quot;set&quot; type was supported in smithy 1.0, but has disappeared in smithy 2.0 in favour of the uniqueItems trait Additionally, Smithy4s allows users to annotate list shapes to customise the type of collection used during code-generation. Smithy does not support generics, therefore all collection are named. Though seemingly tedious, it makes it easier to build tooling (and probably helps languages that do not support generics). Provided the following shape : namespace example list IntList { member: Integer }  You get the following Scala code : package example object IntList extends Newtype[List[Int]] { val id: smithy4s.ShapeId = smithy4s.ShapeId(&quot;example&quot;, &quot;IntList&quot;) val hints: smithy4s.Hints = smithy4s.Hints.empty val underlyingSchema: smithy4s.Schema[List[Int]] = list(int).withId(id).addHints(hints) implicit val schema: smithy4s.Schema[IntList] = bijection(underlyingSchema, IntList(_), (_: IntList).value) }  It is really similar to named primitives. However, for pragmatic reasons, when a structure references a collection in one of its members, the Scala field gets rendered using the de-aliased type (as opposed to the newtype). The IntList newtype is generated mostly as a way to hold the hints and schemas corresponding to the smithy IntList shape. Additionally, the IntList newtype is used by Smithy4s to render Hints values : namespace example @trait list info { member: String } @info(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;) structure A {}  would lead to the following code being rendered in the companion object of A : val hints: Hints = Hints( example.Info(List(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;)), )  This allows to query Hints for Info using the following syntax: hints.get(example.Info) Regarding the underlyingSchema value in the companion object of IntList, you can see that it is constructed using a list function. Conceptually, it encodes this: &quot;if I'm able to encode or decode an A in a specific format, then I should be able to encode or decode a List[A]&quot;. ","version":"Next","tagName":"h3"},{"title":"Enumerations​","type":1,"pageTitle":"Datatypes and schemas","url":"/smithy4s/docs/design/schemas#enumerations","content":"Smithy allows for two types of enumerations : string and integer enumerations. Additionally, smithy4s supports specifying whether an operation is open or closed. An open enumeration allows for holding unknown values, whereas a closed one is strictly limited to a set of specified values. This brings the total number of possible &quot;flavours&quot; of enumerations to 4, which is reified via a smithy4s.schema.EnumTag ADT that comprises 4 different cases : one for each combination between [open, closed] and [int, string]. Enumerations are typically modelled as Algebraic Data types. Each case of an enumeration is associated with both a String and Int value. In the case of intEnum, the string value is the name of the case. In the case of a normal (string) enum, the integer value is the index of the case in the list. Additionally, each enumeration case holds its own hints. Closed enumerations​ Given this smithy code : namespace example intEnum Numbers { ONE = 1 TWO = 2 }  The corresponding generated Scala-code is : sealed abstract class Numbers(_value: String, _name: String, _intValue: Int, _hints: Hints) extends Enumeration.Value { override type EnumType = Numbers override val value: String = _value override val name: String = _name override val intValue: Int = _intValue override val hints: Hints = _hints override def enumeration: Enumeration[EnumType] = Numbers @inline final def widen: Numbers = this } object Numbers extends Enumeration[Numbers] with ShapeTag.Companion[Numbers] { val id: ShapeId = ShapeId(&quot;smithy4s.example&quot;, &quot;Numbers&quot;) val hints: Hints = Hints.empty case object ONE extends Numbers(&quot;ONE&quot;, &quot;ONE&quot;, 1, Hints()) case object TWO extends Numbers(&quot;TWO&quot;, &quot;TWO&quot;, 2, Hints()) val values: List[Numbers] = List( ONE, TWO, ) val tag: EnumTag[Numbers] = EnumTag.ClosedIntEnum implicit val schema: Schema[Numbers] = enumeration(tag, values).withId(id).addHints(hints) }  Open enumeration​ Given this smithy code : namespace example use alloy#openEnum @openEnum intEnum OpenNums { ONE = 1 TWO = 2 }  The corresponding generated Scala-code is : package smithy4s.example import smithy4s.Enumeration import smithy4s.Hints import smithy4s.Schema import smithy4s.ShapeId import smithy4s.ShapeTag import smithy4s.schema.EnumTag import smithy4s.schema.Schema.enumeration sealed abstract class OpenNums(_value: String, _name: String, _intValue: Int, _hints: Hints) extends Enumeration.Value { override type EnumType = OpenNums override val value: String = _value override val name: String = _name override val intValue: Int = _intValue override val hints: Hints = _hints override def enumeration: Enumeration[EnumType] = OpenNums @inline final def widen: OpenNums = this } object OpenNums extends Enumeration[OpenNums] with ShapeTag.Companion[OpenNums] { val id: ShapeId = ShapeId(&quot;smithy4s.example&quot;, &quot;OpenNums&quot;) val hints: Hints = Hints( alloy.OpenEnum(), ) case object ONE extends OpenNums(&quot;ONE&quot;, &quot;ONE&quot;, 1, Hints()) case object TWO extends OpenNums(&quot;TWO&quot;, &quot;TWO&quot;, 2, Hints()) final case class $Unknown(int: Int) extends OpenNums(&quot;$Unknown&quot;, &quot;$Unknown&quot;, int, Hints.empty) val $unknown: Int =&gt; OpenNums = $Unknown(_) val values: List[OpenNums] = List( ONE, TWO, ) val tag: EnumTag[OpenNums] = EnumTag.OpenIntEnum($unknown) implicit val schema: Schema[OpenNums] = enumeration(tag, values).withId(id).addHints(hints) }  As you can see, the main difference between the two is the presence of an final case class $Unknown ADT member in the open enumeration, which allows to capture values that are not defined in the specification. ","version":"Next","tagName":"h3"},{"title":"Endpoint Specific Middleware","type":0,"sectionRef":"#","url":"/smithy4s/docs/guides/endpoint-middleware","content":"","keywords":"","version":"Next"},{"title":"ServerEndpointMiddleware / ClientEndpointMiddleware​","type":1,"pageTitle":"Endpoint Specific Middleware","url":"/smithy4s/docs/guides/endpoint-middleware#serverendpointmiddleware--clientendpointmiddleware","content":"ServerEndpointMiddleware is the interface that we have provided for implementing service middleware. For some use cases, you will need to use the full interface. However, for this guide and for many use cases, you will be able to rely on the simpler interface called ServerEndpointMiddleware.Simple. This interface requires a single method which looks as follows: def prepareWithHints( serviceHints: Hints, endpointHints: Hints ): HttpApp[F] =&gt; HttpApp[F]  This means that given the hints for the service and a specific endpoint, our implementation will provide a transformation of an HttpApp. If you are not familiar with Hints, they are the smithy4s construct that represents Smithy Traits. They are called hints to avoid naming conflicts and confusion with Scala traits. The ClientEndpointMiddleware interface is essentially the same as the one for ServerEndpointMiddleware with the exception that we are returning a transformation on Client[F] instead of HttpApp[F]. This looks like: def prepareWithHints( serviceHints: Hints, endpointHints: Hints ): Client[F] =&gt; Client[F]  ","version":"Next","tagName":"h2"},{"title":"Smithy Spec​","type":1,"pageTitle":"Endpoint Specific Middleware","url":"/smithy4s/docs/guides/endpoint-middleware#smithy-spec","content":"Let's look at the smithy specification that we will use for this guide. First, let's define the service. $version: &quot;2&quot; namespace smithy4s.example.guides.auth use alloy#simpleRestJson @simpleRestJson @httpBearerAuth service HelloWorldAuthService { version: &quot;1.0.0&quot;, operations: [SayWorld, HealthCheck] errors: [NotAuthorizedError] }  Here we defined a service that has two operations, SayWorld and HealthCheck. We defined it such that any of these operations may return an NotAuthorizedError. Finally, we annotated the service with the @httpBearerAuth trait to indicate that the service supports authentication via a bearer token. If you are using a different authentication scheme, you can still follow this guide and adapt it for your needs. You can find a full list of smithy-provided schemes here. If none of the provided traits suit your use case, you can always create a custom trait too. Next, let's define our first operation, SayWorld: @readonly @http(method: &quot;GET&quot;, uri: &quot;/hello&quot;, code: 200) operation SayWorld { output: World } structure World { message: String = &quot;World !&quot; }  There is nothing authentication-specific defined with this operation, this means that the operation inherits the service-defined authentication scheme (httpBearerAuth in this case). Let's contrast this with the HealthCheck operation: @readonly @http(method: &quot;GET&quot;, uri: &quot;/health&quot;, code: 200) @auth([]) operation HealthCheck { output := { @required message: String } }  Notice that on this operation we have added the @auth([]) trait with an empty array. This means that there is no authentication required for this endpoint. In other words, although the service defines an authentication scheme of httpBearerAuth, that scheme will not apply to this endpoint. Finally, let's define the NotAuthorizedError that will be returned when an authentication token is missing or invalid. @error(&quot;client&quot;) @httpError(401) structure NotAuthorizedError { @required message: String }  There is nothing authentication specific about this error, this is a standard smithy http error that will have a 401 status code when returned. If you want to see the full smithy model we defined above, you can do so here. ","version":"Next","tagName":"h2"},{"title":"Server-side Middleware​","type":1,"pageTitle":"Endpoint Specific Middleware","url":"/smithy4s/docs/guides/endpoint-middleware#server-side-middleware","content":"To see the full code example of what we walk through below, go here. We will create a server-side middleware that implements the authentication as defined in the smithy spec above. Let's start by creating a few classes that we will use in our middleware. AuthChecker​ case class ApiToken(value: String) trait AuthChecker { def isAuthorized(token: ApiToken): IO[Boolean] } object AuthChecker extends AuthChecker { def isAuthorized(token: ApiToken): IO[Boolean] = { IO.pure( token.value.nonEmpty ) // put your logic here, currently just makes sure the token is not empty } }  This is a simple class that we will use to check the validity of a given token. This will be more complex in your own service, but we are keeping it simple here since it is out of the scope of this article and implementations will vary widely depending on your specific application. The Inner Middleware Implementation​ This function is what is called once we have made sure that the middleware is applicable for a given endpoint. We will show in the next step how to tell if the middleware is applicable or not. For now though, we will just focus on what the middleware does once we know that it needs to be applied to a given endpoint. def middleware( authChecker: AuthChecker // 1 ): HttpApp[IO] =&gt; HttpApp[IO] = { inputApp =&gt; // 2 HttpApp[IO] { request =&gt; // 3 val maybeKey = request.headers // 4 .get[`Authorization`] .collect { case Authorization( Credentials.Token(AuthScheme.Bearer, value) ) =&gt; value } .map { ApiToken.apply } val isAuthorized = maybeKey .map { key =&gt; authChecker.isAuthorized(key) // 5 } .getOrElse(IO.pure(false)) isAuthorized.ifM( ifTrue = inputApp(request), // 6 ifFalse = IO.raiseError(new NotAuthorizedError(&quot;Not authorized!&quot;)) // 7 ) } }  Let's break down what we did above step by step. The step numbers below correspond to the comment numbers above. Pass an instance of AuthChecker that we can use to verify auth tokens are valid in this middlewareinputApp is the HttpApp[IO] that we are transforming in this middleware.Here we create a new HttpApp, the one that we will be returning from this function we are creating.Here we extract the value of the Authorization header, if it is present.If the header had a value, we now send that value into the AuthChecker to see if it is valid.If the token was found to be valid, we pass the request into the inputApp from step 2 in order to get a response.If the header was found to be invalid, we return the NotAuthorizedError that we defined in our smithy file above. ServerEndpointMiddleware.Simple​ Next, let's create our middleware by implementing the ServerEndpointMiddleware.Simple interface we discussed above. object AuthMiddleware { def apply( authChecker: AuthChecker // 1 ): ServerEndpointMiddleware[IO] = new ServerEndpointMiddleware.Simple[IO] { private val mid: HttpApp[IO] =&gt; HttpApp[IO] = middleware(authChecker) // 2 def prepareWithHints( serviceHints: Hints, endpointHints: Hints ): HttpApp[IO] =&gt; HttpApp[IO] = { serviceHints.get[smithy.api.HttpBearerAuth] match { // 3 case Some(_) =&gt; endpointHints.get[smithy.api.Auth] match { // 4 case Some(auths) if auths.value.isEmpty =&gt; identity // 5 case _ =&gt; mid // 6 } case None =&gt; identity } } } }  Pass in an instance of AuthChecker for the middleware to use. This is how the middleware will know if a given token is valid or not.This is the function that we defined in the step above.Check and see if the service at hand does in fact have the httpBearerAuth trait on it. If it doesn't, then we will not do our auth checks. If it does, then we will proceed.Here we are getting the @auth trait from the operation (endpoint in smithy4s lingo). We need to check for this trait because of step 5.Here we are checking that IF the auth trait is on this endpoint AND the auth trait contains an empty array THEN we are performing NO authentication checks. This is how we handle the @auth([]) trait that is present on the HealthCheck operation we defined above.IF the auth trait is NOT present on the operation, OR it is present AND it contains one or more authentication schemes, we apply the middleware. Using the Middleware​ From here, we can pass our middleware into our SimpleRestJsonBuilder as follows: object HelloWorldAuthImpl extends HelloWorldAuthService[IO] { def sayWorld(): IO[World] = World().pure[IO] def healthCheck(): IO[HealthCheckOutput] = HealthCheckOutput(&quot;Okay!&quot;).pure[IO] } val routes = SimpleRestJsonBuilder .routes(HelloWorldAuthImpl) .middleware(AuthMiddleware(AuthChecker)) .resource  And that's it. Now we have a middleware that will apply an authentication check on incoming requests whenever relevant, as defined in our smithy file. ","version":"Next","tagName":"h2"},{"title":"Client-side Middleware​","type":1,"pageTitle":"Endpoint Specific Middleware","url":"/smithy4s/docs/guides/endpoint-middleware#client-side-middleware","content":"To see the full code example of what we walk through below, go here. It is possible that you have a client where you want to apply a similar type of middleware that alters some part of a request depending on the endpoint being targeted. In this part of the guide, we will show how you can do this for a client using the same smithy specification we defined above. We will make it so our authentication token is only sent if we are targeting an endpoint which requires it. ClientEndpointMiddleware.Simple​ The interface that we define for this middleware is going to look very similar to the one we defined above. This makes sense because this middleware is effectively the dual of the middleware above. object Middleware { private def middleware(bearerToken: String): Client[IO] =&gt; Client[IO] = { // 1 inputClient =&gt; Client[IO] { request =&gt; val newRequest = request.putHeaders( // 2 Authorization(Credentials.Token(AuthScheme.Bearer, bearerToken)) ) inputClient.run(newRequest) } } def apply(bearerToken: String): ClientEndpointMiddleware[IO] = // 3 new ClientEndpointMiddleware.Simple[IO] { private val mid = middleware(bearerToken) def prepareWithHints( serviceHints: Hints, endpointHints: Hints ): Client[IO] =&gt; Client[IO] = { serviceHints.get[smithy.api.HttpBearerAuth] match { case Some(_) =&gt; endpointHints.get[smithy.api.Auth] match { case Some(auths) if auths.value.isEmpty =&gt; identity case _ =&gt; mid } case None =&gt; identity } } } }  Here we are creating an inner middleware function, just like we did above. The only differences are that this time we are adding a value to the request instead of extracting one from it and we are operating on Client instead of HttpApp.Add the Authorization header to the request and pass it to the inputClient that we are transforming in this middleware.This function is actually the exact same as the function for the middleware we implemented above. The only differences are that this apply method accepts a bearerToken as a parameter and returns a function on Client instead of HttpApp. The provided bearerToken is what we will add into the Authorization header when applicable. SimpleRestJsonBuilder​ As above, we now just need to wire our middleware into our actual implementation. Here we are constructing a client and specifying the middleware we just defined. def apply(http4sClient: Client[IO]): Resource[IO, HelloWorldAuthService[IO]] = SimpleRestJsonBuilder(HelloWorldAuthService) .client(http4sClient) .uri(Uri.unsafeFromString(&quot;http://localhost:9000&quot;)) .middleware(Middleware(&quot;my-token&quot;)) // creating our middleware here .resource  ","version":"Next","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Endpoint Specific Middleware","url":"/smithy4s/docs/guides/endpoint-middleware#conclusion","content":"Once again, if you want to see the full code examples of the above, you can find them here. Hopefully this guide gives you a good idea of how you can create a middleware that takes your smithy specification into account. This guide shows a very simple use case of what is possible with a middleware like this. If you have a more advanced use case, you can use this guide as a reference and as always you can reach out to us for insight or help. ","version":"Next","tagName":"h2"},{"title":"Dynamic module","type":0,"sectionRef":"#","url":"/smithy4s/docs/guides/dynamic","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Dynamic module","url":"/smithy4s/docs/guides/dynamic#introduction","content":"It is highly recommended to learn about the library's design before going into this section. Smithy4s is first and foremost a code generation tool for the Smithy language in Scala. Although it does provide interpreters for the Smithy services, which can be used to derive e.g. HTTP clients and servers, the codegen way can only get you so far - there are some situations when it's not sufficient for the job. Code generation works well if your Smithy model changes no more often than your service's implementation - as long as you run your build whenever you make a code change, codegen will also be triggered, and the Scala compiler will ensure you're in sync with the Smithy model in its present state. But what if your Smithy model changes are more frequent than the service? Or what if you simply don't have access to all the Smithy models your code might have to work with? These cases, and possibly others, are why Smithy4s has the dynamic module. ","version":"Next","tagName":"h2"},{"title":"(Why) do we need codegen?​","type":1,"pageTitle":"Dynamic module","url":"/smithy4s/docs/guides/dynamic#why-do-we-need-codegen","content":"As you know by now, Smithy4s's codegen is static - it requires the model to be available at build-time, so that code can be generated and made available to you at compile-time. In short, what happens at build-time are the following steps: Read the Smithy files available to your buildBuild a semantic Smithy model, which is roughly a graph of shapes that refer to each otherGenerate files for each relevant shape in the model (e.g. a service, a structure, an enum...), including metadata (services and schemas). Then, there's the runtime part. Let's say you're building an HTTP client - in that case, what you see as a Smithy4s user is: SimpleRestJson(WeatherService) .client(??? : org.http4s.client.Client[IO]) .make  or more generically: interpretToRestClient(WeatherService)  The steps that the HTTP client interpreter performs to build a high-level client are: Capture a Smithy4s service representing the service you wrote in Smithy. This was generated by Smithy4s's codegen.Analyze the service's endpoints, their input/output schemas, the Hints on these schemas...Transform the service description into a high-level proxy to the underlying client implementation. Turns out that interpreters like this aren't actually aware of the fact that there's code generation involved. As long as you can provide a data structure describing your service, its endpoints and their schemas (which is indeed the Service type), you can use any interpreter that requires one: code generation is just a means to derive such a data structure automatically from your Smithy model. This all is why you don't need code generation to benefit from the interpreters - you just need a way to instantiate a Smithy4s Service (or Schema, if that's what your interpreter operates on). The Dynamic module of smithy4s was made exactly for that purpose. ","version":"Next","tagName":"h2"},{"title":"The Dynamic way​","type":1,"pageTitle":"Dynamic module","url":"/smithy4s/docs/guides/dynamic#the-dynamic-way","content":"In the previous section, we looked at the steps performed at build time to generate code: Read Smithy filesBuild a Smithy modelGenerate Scala files with Smithy4s schemas. Don't be fooled - although we had Smithy files as the input and Scala files as the output, the really important part was getting from the Smithy model to the Service and Schema instances representing it. The Dynamic module of smithy4s provides a way to do this at runtime. And the runtime part, where the interpreter runs? It's the same as before! The Service and Schema interfaces are identical regardless of the static/dynamic usecase, and so are the interpreters1. ","version":"Next","tagName":"h2"},{"title":"Loading a dynamic model​","type":1,"pageTitle":"Dynamic module","url":"/smithy4s/docs/guides/dynamic#loading-a-dynamic-model","content":"First of all, you need the dependency: libraryDependencies ++= Seq( // version sourced from the plugin &quot;com.disneystreaming.smithy4s&quot; %% &quot;smithy4s-dynamic&quot; % smithy4sVersion.value )  Now, you need a Smithy model. There are essentially three ways to get one: Load a model using the awslabs/smithy library's ModelAssemblerLoad a serialized model from a JSON file (example), orDeserialize or generate the smithy4s.dynamic.model.Model data structure in any way you want, on your own. The ModelAssembler way only works on the JVM, because Smithy's reference implementation is a Java library. We'll use that way for this guide: import software.amazon.smithy.model.Model val s = &quot;&quot;&quot; $version: &quot;2&quot; namespace weather use alloy#simpleRestJson @simpleRestJson service WeatherService { operations: [GetWeather] } @http(method: &quot;GET&quot;, uri: &quot;/weather/{city}&quot;) operation GetWeather { input := { @httpLabel @required city: String } output := { @required weather: String } } structure Dog { @required name: String } &quot;&quot;&quot; val model = Model .assembler() .addUnparsedModel( &quot;weather.smithy&quot;, s, ) .discoverModels() .assemble() .unwrap()  The entrypoint to loading models is DynamicSchemaIndex. import smithy4s.dynamic.DynamicSchemaIndex val dsi = DynamicSchemaIndex.loadModel(model) // dsi: DynamicSchemaIndex = smithy4s.dynamic.internals.DynamicSchemaIndexImpl@2bd90040  For alternative ways to load a DSI, see DynamicSchemaIndex.load. ","version":"Next","tagName":"h2"},{"title":"Using the DSI​","type":1,"pageTitle":"Dynamic module","url":"/smithy4s/docs/guides/dynamic#using-the-dsi","content":"Having a DynamicSchemaIndex, we can iterate over all the services available to it: dsi.allServices.map(_.service.id) // res0: Iterable[smithy4s.ShapeId] = List( // ShapeId(namespace = &quot;weather&quot;, name = &quot;WeatherService&quot;) // )  as well as the schemas: dsi.allSchemas.map(_.shapeId).filter(_.namespace == &quot;weather&quot;) // res1: Iterable[smithy4s.ShapeId] = List( // ShapeId(namespace = &quot;weather&quot;, name = &quot;GetWeatherInput&quot;), // ShapeId(namespace = &quot;weather&quot;, name = &quot;GetWeatherOutput&quot;), // ShapeId(namespace = &quot;weather&quot;, name = &quot;Dog&quot;) // )  You can also access a service or schema by ID: import smithy4s.ShapeId dsi.getService(ShapeId(&quot;weather&quot;, &quot;WeatherService&quot;)).get.service.id // res2: ShapeId = ShapeId(namespace = &quot;weather&quot;, name = &quot;WeatherService&quot;) dsi.getSchema(ShapeId(&quot;weather&quot;, &quot;Dog&quot;)).get.shapeId // res3: ShapeId = ShapeId(namespace = &quot;weather&quot;, name = &quot;Dog&quot;)  Note that you don't know the exact type of a schema at compile-time: import smithy4s.Schema dsi.getSchema(ShapeId(&quot;weather&quot;, &quot;Dog&quot;)).get // res4: Schema[_] = StructSchema( // shapeId = ShapeId(namespace = &quot;weather&quot;, name = &quot;Dog&quot;), // hints = Impl(memberHintsMap = Map(), targetHintsMap = Map()), // fields = Vector( // Field( // label = &quot;name&quot;, // schema = PrimitiveSchema( // shapeId = ShapeId(namespace = &quot;smithy.api&quot;, name = &quot;String&quot;), // hints = Impl( // memberHintsMap = Map( // ShapeId(namespace = &quot;smithy.api&quot;, name = &quot;required&quot;) -&gt; DynamicBinding( // keyId = ShapeId(namespace = &quot;smithy.api&quot;, name = &quot;required&quot;), // value = DObject(value = ListMap()) // ) // ), // targetHintsMap = Map() // ), // tag = PString // ), // get = Accessor(index = 0) // ) // ), // make = &lt;function1&gt; // )  It is very similar for services. This is simply due to the fact that at compile-time (which is where typechecking happens) we have no clue what the possible type of the schema could be. After all, the String representing the model doesn't have to be constant - it could be fetched from the network, and even vary throughout the lifetime of our application! This doesn't forbid us from using these dynamic goodies in interpreters, though. ","version":"Next","tagName":"h2"},{"title":"Case study: dynamic HTTP client​","type":1,"pageTitle":"Dynamic module","url":"/smithy4s/docs/guides/dynamic#case-study-dynamic-http-client","content":"Let's make a REST client for a dynamic service. We'll start by writing an interpreter. &quot;But wait, weren't we supposed to be able to use the existing interpreters?&quot; That's true - the underlying implementation will use the interpreters made for the static world as well. However, due to the strangely-typed nature of the dynamic world, we have to deal with some complexity that's normally invisible to the user. For example, you can write this in the static world: import cats.effect.IO import weather._ // imagine this comes from an interpreter val client: WeatherService[IO] = ??? : WeatherService[IO] client.getWeather(city = &quot;hello&quot;)  but you can't do it if your model gets loaded dynamically! You wouldn't be able to compile that code, because there's no way to tell what services you'll load at runtime. This means that we'll need a different way to pass the following pieces to an interpreter at runtime: the service being used (HelloWorldService)the operation being called (Hello)the operation input (a single parameter: name = &quot;Hello&quot;) Let's get to work - we'll need a function that takes a service and its interpreter, the operation name, and some representation of its input. For that input, we'll use smithy4s's Document type. import smithy4s.Document import smithy4s.Endpoint import smithy4s.Service import smithy4s.kinds.FunctorAlgebra import smithy4s.kinds.FunctorInterpreter import cats.effect.IO def run[Alg[_[_, _, _, _, _]]]( service: Service[Alg], operationName: String, input: Document, alg: FunctorAlgebra[Alg, IO] ): IO[Document] = { val endpoint = service.endpoints.find(_.id.name == operationName).get runEndpoint(endpoint, input, service.toPolyFunction(alg)) } def runEndpoint[Op[_, _, _, _, _], I, O]( endpoint: Endpoint[Op, I, _, O, _, _], input: Document, interp: FunctorInterpreter[Op, IO], ): IO[Document] = { // Deriving these codecs is a costly operation, so we don't recommend doing it for every call. // We do it here for simplicity. val inputDecoder = Document.Decoder.fromSchema(endpoint.input) val outputEncoder = Document.Encoder.fromSchema(endpoint.output) val decoded: I = inputDecoder.decode(input).toTry.get val result: IO[O] = interp(endpoint.wrap(decoded)) result.map(outputEncoder.encode(_)) }  That code is a little heavy and abstract, but there's really no way to avoid abstraction - after all, we need to be prepared for any and all models that our users might give us, so we need to be very abstract! To explain a little bit: FunctorAlgebra[Alg, IO] is Alg[IO] (for a specific shape of Alg). This could be HelloWorldService[IO], if we knew the types (which we don't, because we're in the dynamic, runtime world). Related to that, FunctorInterpreter[Op, IO] is a different way to view an Alg[IO], which is as a higher-kinded function. See this document for more explanation. The steps we're taking are: Find the endpoint within the service, using its operation nameIn runEndpoint, decode the input Document to the type the endpoint expectsRun the interpreter using the decoded inputEncode the output to a Document. Let's see this in action with our actual service! But first, just for this guide, we'll define the routes for a fake instance of the server we're going to call: import org.http4s.HttpApp import org.http4s.MediaType import org.http4s.headers.`Content-Type` import org.http4s.dsl.io._ val routes = HttpApp[IO] { case GET -&gt; Root / &quot;weather&quot; / city =&gt; Ok(s&quot;&quot;&quot;{&quot;weather&quot;: &quot;sunny in $city&quot;}&quot;&quot;&quot;).map( _.withContentType(`Content-Type`(MediaType.application.json)) ) } // routes: HttpApp[IO] = Kleisli( // run = org.http4s.Http$$$Lambda$28469/0x00000008031357e0@36196de0 // )  Now we'll build a client based on the service we loaded earlier, using that route as a fake server: import org.http4s.client.Client import smithy4s.http4s.SimpleRestJsonBuilder // first, we need some Service instance - we get one from the DynamicSchemaIndex we made earlier val service = dsi.getService(ShapeId(&quot;weather&quot;, &quot;WeatherService&quot;)).get val client = SimpleRestJsonBuilder(service.service) .client(Client.fromHttpApp(routes)) .make .toTry .get  And finally, what we've been working towards all this time - we'll select the GetWeather operation, pass a Document representing our input, and the client we've just built. import cats.effect.unsafe.implicits._ run( service = service.service, operationName = &quot;GetWeather&quot;, input = Document.obj(&quot;city&quot; -&gt; Document.fromString(&quot;London&quot;)), alg = client, ).unsafeRunSync().show // res6: String = &quot;{weather=\\&quot;sunny in London\\&quot;}&quot;  Enjoy the view! As an added bonus, because we happen to have this service at build-time, we can use the same method with a static, compile-time service: import weather._ val clientStatic = SimpleRestJsonBuilder(WeatherService) .client(Client.fromHttpApp(routes)) .make .toTry .get // clientStatic: WeatherServiceGen[[I, E, O, SI, SO]IO[O]] = weather.WeatherServiceOperation$Transformed@5397b08a run( service = WeatherService, operationName = &quot;GetWeather&quot;, input = Document.obj(&quot;city&quot; -&gt; Document.fromString(&quot;London&quot;)), alg = clientStatic, ).unsafeRunSync().show // res7: String = &quot;{weather=\\&quot;sunny in London\\&quot;}&quot;  Again, this is equivalent to the following call in the static approach: clientStatic.getWeather(city = &quot;London&quot;).unsafeRunSync() // res8: GetWeatherOutput = GetWeatherOutput(weather = &quot;sunny in London&quot;)  That is, assuming they're written correctly to make no assumptions about the usecase.↩ ","version":"Next","tagName":"h2"},{"title":"Extracting Request Information","type":0,"sectionRef":"#","url":"/smithy4s/docs/guides/extract-request-info","content":"","keywords":"","version":"Next"},{"title":"What is IOLocal?​","type":1,"pageTitle":"Extracting Request Information","url":"/smithy4s/docs/guides/extract-request-info#what-is-iolocal","content":"IOLocalis a construct that allows for sharing context across the scope of a Fiber. This means it allows you to get and set some value A in the IOLocal. This value will be accessible across the current Fiber. As a Fiber is forked into new fibers, the value of A is carried over to the new Fiber. However, the new Fiber will not be able to update the value kept on its parent or sibling fibers. This diagram, adapted from the IOLocal docs, illustrates this well:  ","version":"Next","tagName":"h2"},{"title":"Example Implementation​","type":1,"pageTitle":"Extracting Request Information","url":"/smithy4s/docs/guides/extract-request-info#example-implementation","content":"","version":"Next","tagName":"h2"},{"title":"Smithy Spec​","type":1,"pageTitle":"Extracting Request Information","url":"/smithy4s/docs/guides/extract-request-info#smithy-spec","content":"For this example, we are going to be working with the following smithy specification (taken from smithy4s repo): $version: &quot;2&quot; namespace smithy4s.example.hello use alloy#simpleRestJson @simpleRestJson @tags([&quot;testServiceTag&quot;]) service HelloWorldService { version: &quot;1.0.0&quot;, // Indicates that all operations in `HelloWorldService`, // here limited to Hello, can return `GenericServerError`. errors: [GenericServerError, SpecificServerError], operations: [Hello] } @error(&quot;server&quot;) @httpError(500) structure GenericServerError { message: String } @error(&quot;server&quot;) @httpError(599) structure SpecificServerError { message: String } @http(method: &quot;POST&quot;, uri: &quot;/{name}&quot;, code: 200) @tags([&quot;testOperationTag&quot;]) operation Hello { input: Person, output: Greeting } structure Person { @httpLabel @required name: String, @httpQuery(&quot;town&quot;) town: String } structure Greeting { @required message: String }  See our getting started documentation for instructions on how to use this specification to generate scala code. ","version":"Next","tagName":"h3"},{"title":"Service Implementation​","type":1,"pageTitle":"Extracting Request Information","url":"/smithy4s/docs/guides/extract-request-info#service-implementation","content":"Let's start by creating a case class that we will use to hold the value of some headers from our request. case class RequestInfo(contentType: String, userAgent: String)  This class will give us a spot to place the Content-Type and User-Agent headers, respectively. These are just shown as an example. We could instead pass any other header or part of the request. From here, we can implement the HelloWorldService interface that smithy4s generated from the specification above. import smithy4s.example.hello._ import cats.effect.IO import cats.effect.IOLocal final class HelloWorldServiceImpl(requestInfo: IO[RequestInfo]) extends HelloWorldService[IO] { def hello(name: String, town: Option[String]): IO[Greeting] = requestInfo.flatMap { reqInfo: RequestInfo =&gt; IO.println(&quot;REQUEST_INFO: &quot; + reqInfo) .as(Greeting(s&quot;Hello, $name&quot;)) } }  This is a basic implementation that, in addition to returning a Greeting, prints the RequestInfo out to the console. Note that it is getting the RequestInfo from the IO[RequestInfo] that is being passed in as a constructor parameter. This IOwill be created using the same IOLocal instance is passed to our middleware implementation. That way, the middleware can set the RequestInfo value that we are reading here. ","version":"Next","tagName":"h3"},{"title":"Middleware​","type":1,"pageTitle":"Extracting Request Information","url":"/smithy4s/docs/guides/extract-request-info#middleware","content":"Below is the middleware implementation. It extracts the Content-Type and User-Agent headers and passes them along in the IOLocalinstance it is provided. import cats.data._ import org.http4s.HttpRoutes import cats.syntax.all._ import org.http4s.headers.{`Content-Type`, `User-Agent`} object Middleware { def withRequestInfo( routes: HttpRoutes[IO], local: IOLocal[Option[RequestInfo]] ): HttpRoutes[IO] = HttpRoutes[IO] { request =&gt; val requestInfo = for { contentType &lt;- request.headers.get[`Content-Type`].map(ct =&gt; s&quot;${ct.mediaType.mainType}/${ct.mediaType.subType}&quot;) userAgent &lt;- request.headers.get[`User-Agent`].map(_.product.toString) } yield RequestInfo( contentType, userAgent ) OptionT.liftF(local.set(requestInfo)) *&gt; routes(request) } }  ","version":"Next","tagName":"h3"},{"title":"Wiring it Together​","type":1,"pageTitle":"Extracting Request Information","url":"/smithy4s/docs/guides/extract-request-info#wiring-it-together","content":"Now that we have our service implementation and our middleware, we need to combine them to create our application. import cats.effect.kernel.Resource object Routes { private val docs = smithy4s.http4s.swagger.docs[IO](smithy4s.example.hello.HelloWorldService) def getAll(local: IOLocal[Option[RequestInfo]]): Resource[IO, HttpRoutes[IO]] = { val getRequestInfo: IO[RequestInfo] = local.get.flatMap { case Some(value) =&gt; IO.pure(value) case None =&gt; IO.raiseError(new IllegalAccessException(&quot;Tried to access the value outside of the lifecycle of an http request&quot;)) } smithy4s.http4s.SimpleRestJsonBuilder .routes(new HelloWorldServiceImpl(getRequestInfo)) .resource .map { routes =&gt; Middleware.withRequestInfo(routes &lt;+&gt; docs, local) } } }  Here we are creating our routes (with swagger docs) and passing them to our middleware. The result of applying the Middleware is our final routes. We also turn our IOLocal into an IO[RequestInfo] for the HelloWorldServiceImpl. We do this because the service implementation does not need to know that the value is coming from an IOLocal or that the value is optional (since it will always be populated by our middleware). Doing it this way allows us to reduce the complexity in the service implementation. Finally, we create our main class and construct the http4s server. import cats.effect.IOApp import com.comcast.ip4s._ import org.http4s.ember.server.EmberServerBuilder object Main extends IOApp.Simple { def run: IO[Unit] = IOLocal(Option.empty[RequestInfo]).flatMap { local =&gt; Routes .getAll(local) .flatMap { routes =&gt; EmberServerBuilder .default[IO] .withHost(host&quot;localhost&quot;) .withPort(port&quot;9000&quot;) .withHttpApp(routes.orNotFound) .build } .useForever } }  Notice that we create the IOLocal with Option.empty[RequestInfo]. This is because IOLocal requires a value to be constructed. However, this value will never be used in practice. This is because we are setting the value in the middleware on every request prior to the request being handled by our HelloWorldService implementation. ","version":"Next","tagName":"h3"},{"title":"Testing it out​","type":1,"pageTitle":"Extracting Request Information","url":"/smithy4s/docs/guides/extract-request-info#testing-it-out","content":"With the above in place, we can run our application and test it out. curl -X 'POST' \\ 'http://localhost:9000/Test' \\ -H 'User-Agent: Chrome/103.0.0.0' \\ -H 'Content-Type: application/json'  Running this curl will cause the following to print out to the console: REQUEST_INFO: RequestInfo(Some(application/json),Some(Chrome/103.0.0.0))  ","version":"Next","tagName":"h3"},{"title":"Alternative Methods​","type":1,"pageTitle":"Extracting Request Information","url":"/smithy4s/docs/guides/extract-request-info#alternative-methods","content":"If you are working with a tagless F[_] rather than IO directly, you may want to check out Chris Davenport's implementation of FiberLocal. You can also use Kleisli to accomplish the same things we showed in this tutorial and you are welcome to do so if you prefer that. We opted to show an example with IOLocal since it allows users to use IO directly, without monad transformers, which many users will be more comfortable with. Similarly, you could use Local from cats-mtl or probably a variety of other approaches. We recommend you use whatever fits the best with your current application design. ","version":"Next","tagName":"h2"},{"title":"Converting Smithy4s Schemas and Services to Smithy","type":0,"sectionRef":"#","url":"/smithy4s/docs/guides/schema-to-smithy","content":"","keywords":"","version":"Next"},{"title":"Creating a DynamicSchemaIndex​","type":1,"pageTitle":"Converting Smithy4s Schemas and Services to Smithy","url":"/smithy4s/docs/guides/schema-to-smithy#creating-a-dynamicschemaindex","content":"The first step is to take the services and schemas you'd like included in your smithy model and add them to a DynamicSchemaIndex using the provided builder. import smithy4s.dynamic.DynamicSchemaIndex val dynamicSchemaIndex = DynamicSchemaIndex.builder .addService[smithy4s.example.KVStoreGen] .addSchema[smithy4s.example.FaceCard] .build() // dynamicSchemaIndex: DynamicSchemaIndex = smithy4s.dynamic.DynamicSchemaIndex$BuilderImpl$$anon$1@12453118  ","version":"Next","tagName":"h2"},{"title":"Converting to Smithy Model​","type":1,"pageTitle":"Converting Smithy4s Schemas and Services to Smithy","url":"/smithy4s/docs/guides/schema-to-smithy#converting-to-smithy-model","content":"Now that we have a DynamicSchemaIndex, we can convert to a smithy model object from the smithy-model Java library. This feature is only supported on the JVM and not ScalaJS or Scala Native. val model = dynamicSchemaIndex.toSmithyModel // model: software.amazon.smithy.model.Model = software.amazon.smithy.model.Model@38521e1d  ","version":"Next","tagName":"h2"},{"title":"Rendering as a String​","type":1,"pageTitle":"Converting Smithy4s Schemas and Services to Smithy","url":"/smithy4s/docs/guides/schema-to-smithy#rendering-as-a-string","content":"If you wish to render the smithy Model as a String, smithy-model provides a method to accomplish this. import software.amazon.smithy.model.shapes.SmithyIdlModelSerializer import scala.jdk.CollectionConverters._ import java.nio.file.Path val smithyFiles: Map[Path, String] = SmithyIdlModelSerializer .builder() .build() .serialize(model) .asScala .toMap // smithyFiles: Map[Path, String] = Map( // smithy4s.example.smithy -&gt; &quot;&quot;&quot;$version: &quot;2.0&quot; // // namespace smithy4s.example // // service KVStore { // operations: [ // Delete // Get // Put // ] // } // // operation Delete { // input: Key // output: Unit // errors: [ // KeyNotFoundError // UnauthorizedError // ] // } // // operation Get { // input: Key // output: Value // errors: [ // KeyNotFoundError // UnauthorizedError // ] // } // // operation Put { // input: KeyValue // output: Unit // errors: [ // UnauthorizedError // ] // } // // structure Key { // @required() // key: String // } // // @error(&quot;client&quot;) // structure KeyNotFoundError { // @required() // message: String // } // ...  ","version":"Next","tagName":"h2"},{"title":"Testing Smithy4s Applications","type":0,"sectionRef":"#","url":"/smithy4s/docs/guides/testing","content":"","keywords":"","version":"Next"},{"title":"What Smithy4s Does​","type":1,"pageTitle":"Testing Smithy4s Applications","url":"/smithy4s/docs/guides/testing#what-smithy4s-does","content":"For starters, let's briefly cover what it is that Smithy4s does. At a high level, Smithy4s takes your Smithy model and generates Scala code based on that model. The model is essentially just a Scala representation of the Smithy model. The generated code does not contain any logic for any specific library such as http4s or jsoniter. Instead, it contains abstractions that Smithy4s itself defines that interpreters can be based on. This means that the generated code is not coupled to any library (other than Smithy4s itself). The interpreters that we have created in Smithy4s will then take the generated code and use it to power, for example, an HTTP service that uses http4s and jsoniter. ","version":"Next","tagName":"h2"},{"title":"How we Test Smithy4s​","type":1,"pageTitle":"Testing Smithy4s Applications","url":"/smithy4s/docs/guides/testing#how-we-test-smithy4s","content":"It is important to understand how Smithy4s works so you can begin to conceptualize how we test Smithy4s and its interpreters. We will not go into much detail on this point, but the main ways we test these are through: Unit tests on the interpreters. These tests isolate the interpreters directly and test their functionality. An example of this is the Jsoniter interpreter. We are able to isolate its functionality and test that it is working as intended.Protocol tests. These tests are auto-generated from Smithy-defined traits. They are sort of like integration tests in the sense that they test all the relevant layers of a smithy4s application by connecting, for example, the HTTP layer with the JSON serialization layer. The main goal of these tests is to make sure that Smithy4s is handling edge cases properly and overall conforms to the protocol(s) we have defined. For more on protocol testing, you can check out the Smithy documentation. ","version":"Next","tagName":"h2"},{"title":"Testing your API​","type":1,"pageTitle":"Testing Smithy4s Applications","url":"/smithy4s/docs/guides/testing#testing-your-api","content":"Now the question that remains is what all of this means for your applications which use Smithy4s. Our basic recommendation is going to come down to: test what you feel needs to be tested, but make sure you understand what it is that you are testing. For example, we would not generally recommend that you test the Smithy4s interpreters in your code (for example the http4s routes that you get when you use SimpleRestJsonBuilder). One of the main appeals of Smithy4s is that it abstracts away concerns such as request routing and the encoding/decoding of payloads. This is why we strive to be thorough in our testing: so you don't need to worry about testing whether or not Smithy4s is doing its job. That being said, if you don't trust Smithy4s and want to test it anyway, that is totally fine too. Ultimately Smithy4s as a project will benefit if you do test it and find any bugs that we can then fix. So in any case, we are supportive of your decision. Another reason you may think of testing the Smithy4s interpreters is to make sure that their implementation, such as the way they encode something in JSON, lines up with some requirements that you have. This is fair enough, but realize that the thing you are really testing here is your understanding of how Smithy4s works. That may be worth your while, or it may not be. The decision is ultimately up to you. If this is your reason for testing, you may want to explore contract-based testing as outlined below. Note that if you are going to test Smithy4s interpreter behaviors, you should not use Smithy4s to test them. We have occasionally seen the pattern where someone uses a Smithy4s client to test a Smithy4s server. This type of testing has very little benefit since much of the same logic is used for each of these interpreters. This means that the interpreters you are testing could both have the same bug and your tests would not catch it. On the other hand, we do recommend that you test the implementation of your service. For example, if Smithy4s generates a service interface called HelloWorldService, you will implement that interface and place your business logic within it. We recommend that you test all of your business logic since this is outside the scope of what Smithy4s controls. ","version":"Next","tagName":"h2"},{"title":"Schema and Contract Testing​","type":1,"pageTitle":"Testing Smithy4s Applications","url":"/smithy4s/docs/guides/testing#schema-and-contract-testing","content":"Contract testing is a form of testing that checks that the contracts which services and clients agree upon are stable over time. Note that schema-based tests and contract-based test are not the same thing. Schema tests are concerned with checking that the data sent and received conforms to a specified schema or schemas. An example where contract testing differs is, for example, a client may expect a certain error response to be returned whenever certain conditions are met in the request. A schema can capture what errors may possibly be sent, but it will not capture which error should be triggered by a specific request. For your specific use case, you may have a need to employ schema-based and/or contract-based testing. Schema based testing would be one way of checking that schema changes over time do not impact existing clients. Contract-based testing could accomplish this same thing and more. However, contract based testing is usually more difficult to implement than schema-based testing so you may find it not to be worth it for your use case. In either case, remember to make sure you know what it is you are testing and what you are not. ","version":"Next","tagName":"h2"},{"title":"TL;DR​","type":1,"pageTitle":"Testing Smithy4s Applications","url":"/smithy4s/docs/guides/testing#tldr","content":"Ultimately our recommendation is that you unit test all of your business logic as well as any custom implementations you have created on top of Smithy4s. You should be able to leave the rest of the unit testing up to us. However, your requirements, concerns, and experience may vary and we encourage you to do whatever will help you write the best software. Depending on your use case, you may find value in Schema or Contract testing. These methods can help you make sure your API is stable for consumers over time. ","version":"Next","tagName":"h2"},{"title":"Smithy Model preprocessing","type":0,"sectionRef":"#","url":"/smithy4s/docs/guides/model-preprocessing","content":"","keywords":"","version":"Next"},{"title":"Starting Smithy Model​","type":1,"pageTitle":"Smithy Model preprocessing","url":"/smithy4s/docs/guides/model-preprocessing#starting-smithy-model","content":"namespace preprocessed @trait(selector: &quot;structure &gt; member&quot;) structure removeBeforeCodegen {} structure MyStruct { @required name: String @removeBeforeCodegen id: String }  Here we have defined a trait removeBeforeCodegen. We have marked the id member of MyStruct with this trait. As such, we will implement a transformer which will lead to the model looking as follows: namespace preprocessed structure MyStruct { @required name: String }  This is the model that will ultimately be fed into the Smithy4s code generation tooling. ","version":"Next","tagName":"h2"},{"title":"Note on third party models​","type":1,"pageTitle":"Smithy Model preprocessing","url":"/smithy4s/docs/guides/model-preprocessing#note-on-third-party-models","content":"It is likely that you will want to annotate third party models. Remember that Smithy allows for annotating shapes with traits a posteriori, via the following syntax : apply preprocessed#MyStruct$id @removeBeforeCodegen  This lets you regain control over models that came from third party before running the code-generation. ","version":"Next","tagName":"h2"},{"title":"Create a new build project/module to hold a ProjectionTransformer​","type":1,"pageTitle":"Smithy Model preprocessing","url":"/smithy4s/docs/guides/model-preprocessing#create-a-new-build-projectmodule-to-hold-a-projectiontransformer","content":"A model preprocessor is essentially an implementation of the software.amazon.smithy.build.ProjectionTransformerinterface, provided by the official smithy-build library. This code is leveraged at build-time, and it is unlikely something that developers want in the runtime classpath of their application. Therefore, a bespoke project/module must be created to hold the implementation. ","version":"Next","tagName":"h2"},{"title":"SBT​","type":1,"pageTitle":"Smithy Model preprocessing","url":"/smithy4s/docs/guides/model-preprocessing#sbt","content":"In our build.sbt file we will create a new project called preprocessors that looks as follows: lazy val preprocessors = (project in file(&quot;preprocessors&quot;)) .settings( scalaVersion := &quot;2.12.13&quot;, // 2.12 to match what SBT uses name := &quot;preprocessors&quot;, libraryDependencies += &quot;software.amazon.smithy&quot; % &quot;smithy-build&quot; % smithy4s.codegen.BuildInfo.smithyVersion )  ","version":"Next","tagName":"h3"},{"title":"Mill​","type":1,"pageTitle":"Smithy Model preprocessing","url":"/smithy4s/docs/guides/model-preprocessing#mill","content":"import mill._ import scalalib._ object preprocessors extends ScalaModule { def scalaVersion = &quot;2.13.10&quot; // 2.13 to match what Mill uses def ivyDeps = Agg( s&quot;software.amazon.smithy:smithy-build:${smithy4s.codegen.BuildInfo.smithyVersion}&quot; ) }  ","version":"Next","tagName":"h3"},{"title":"Implement the ProjectionTransformer​","type":1,"pageTitle":"Smithy Model preprocessing","url":"/smithy4s/docs/guides/model-preprocessing#implement-the-projectiontransformer","content":"Here is an example of a transformer that will remove the members marked with the removeBeforeCodegentrait as discussed above. Note that the result of the getName method is significant, as it will be referenced in the build later, but it does not have to match the name of the class. package preprocessors import software.amazon.smithy.build._ import software.amazon.smithy.model._ import software.amazon.smithy.model.shapes._ import software.amazon.smithy.model.traits._ final class RemoveBeforeCodegenTransformation extends ProjectionTransformer { def getName() = { &quot;RemoveBeforeCodegenTransformation&quot; } def transform(ctx: TransformContext) : Model = { val toRemove = ctx .getModel() .getShapesWithTrait(ShapeId.from(&quot;preprocessed#removeBeforeCodegen&quot;)) ctx.getTransformer().removeShapes(ctx.getModel(), toRemove) } }  Inside the transform method we remove all shapes that are marked with the removeBeforeCodegen trait, before returning the final model. ","version":"Next","tagName":"h2"},{"title":"Register the Transformer​","type":1,"pageTitle":"Smithy Model preprocessing","url":"/smithy4s/docs/guides/model-preprocessing#register-the-transformer","content":"We need to register the Transformer so that the Smithy tooling is be able to find it when necessary. We do this by creating the following file : for SBT : src/main/resources/META-INF/services/software.amazon.smithy.build.ProjectionTransformerfor Mill : resources/META-INF/services/software.amazon.smithy.build.ProjectionTransformer This file contains a list of newline-delimited fully qualified names, of all the ProjectionTransformer implementations contained by our project. For our use-case, it looks like this : preprocessors.RemoveBeforeCodegenTransformation  NB : this registration is dictated by the Service Provider Interface (aka SPI). It is the same mechanism that the Scala compiler uses to find compiler plugins from the classpath. ","version":"Next","tagName":"h2"},{"title":"Wire up​","type":1,"pageTitle":"Smithy Model preprocessing","url":"/smithy4s/docs/guides/model-preprocessing#wire-up","content":"Now, we need to indicate to the smithy4s build plugin which transformers should be applied prior to code generation in our application project. We also need to wire the preprocessors project/module to our application project in a way that ensures the transformer does not end up in the runtime classpath of the application. ","version":"Next","tagName":"h2"},{"title":"SBT​","type":1,"pageTitle":"Smithy Model preprocessing","url":"/smithy4s/docs/guides/model-preprocessing#sbt-1","content":"Now, in our project that is using the Smithy4s SBT plugin (.enablePlugins(Smithy4sCodegenPlugin)) we need to add the following settings: lazy val app = project.in(file(&quot;app&quot;)) .enablePlugins(Smithy4sCodegenPlugin) .settings( // ... // Must match the `getName` method implemented above Compile / smithy4sModelTransformers += &quot;RemoveBeforeCodegenTransformation&quot;, Compile / smithy4sAllDependenciesAsJars += (preprocessors / Compile / packageBin).value )  ","version":"Next","tagName":"h3"},{"title":"Mill​","type":1,"pageTitle":"Smithy Model preprocessing","url":"/smithy4s/docs/guides/model-preprocessing#mill-1","content":"object app extends Smithy4sModule { // ... def smithy4sModelTransformers = T { List( // Must match the `getName` method implemented above &quot;RemoveBeforeCodegenTransformation&quot; ) } def smithy4sAllDependenciesAsJars = T { preprocessors.jar() :: super.smithy4sAllDepencenciesAsJars() } }  ","version":"Next","tagName":"h3"},{"title":"Outcome​","type":1,"pageTitle":"Smithy Model preprocessing","url":"/smithy4s/docs/guides/model-preprocessing#outcome","content":"This results in the generated MyStruct case class to look like this : // note the lack of the `id` field which was removed by the preprocessor case class MyStruct(name: String)  of course, this is but an example, but some models contain thousands of shapes. Automating the preprocessing of these models is extremely powerful. ","version":"Next","tagName":"h2"},{"title":"Directory Structure​","type":1,"pageTitle":"Smithy Model preprocessing","url":"/smithy4s/docs/guides/model-preprocessing#directory-structure","content":"In case the directory and file structure above was hard to follow, here is a tree example of what it would look like for this example: ","version":"Next","tagName":"h2"},{"title":"SBT​","type":1,"pageTitle":"Smithy Model preprocessing","url":"/smithy4s/docs/guides/model-preprocessing#sbt-2","content":"├── build.sbt ├── app │ └── src │ └── main │ ├── scala │ │ └── com │ │ └── example │ │ └── Main.scala │ └── smithy │ └── preproccessed.smithy // The first smithy snippet shown above ├── project │ ├── build.properties │ └── plugins.sbt └── preprocessors └── src └── main ├── resources │ └── META-INF │ └── services │ └── software.amazon.smithy.build.ProjectionTransformer // The file which registers our ProjectionTransformer └── scala └── preprocessors └── RemoveBeforeCodegenTransformation.scala // The ProjectionTransformer  ","version":"Next","tagName":"h3"},{"title":"Mill​","type":1,"pageTitle":"Smithy Model preprocessing","url":"/smithy4s/docs/guides/model-preprocessing#mill-2","content":"├── build.sc ├── app │ ├── src │ │ └── com │ │ └── example │ │ └── Main.scala │ └── smithy │ └── preproccessed.smithy // The first smithy snippet shown above └── preprocessors └── src │ └── preprocessors │ └── RemoveBeforeCodegenTransformation.scala // The ProjectionTransformer ├── resources │ └── META-INF │ └── services │ └── software.amazon.smithy.build.ProjectionTransformer // The file which registers our ProjectionTransformer  ","version":"Next","tagName":"h3"},{"title":"Learning resources","type":0,"sectionRef":"#","url":"/smithy4s/docs/learning-resources","content":"","keywords":"","version":"Next"},{"title":"Text​","type":1,"pageTitle":"Learning resources","url":"/smithy4s/docs/learning-resources#text","content":"Smithy homepageSmithy4s fullstack (blogpost series)An intro to codegen with AWS Smithy ","version":"Next","tagName":"h2"},{"title":"Videos​","type":1,"pageTitle":"Learning resources","url":"/smithy4s/docs/learning-resources#videos","content":"Scaling APIs with SmithyPain-free APIs with Smithy4sSmithy/Smithy4s course by @kubukozRevisiting visitors: a talk about generalising serialisation ","version":"Next","tagName":"h2"},{"title":"Known Issues","type":0,"sectionRef":"#","url":"/smithy4s/docs/known-issues","content":"","keywords":"","version":"Next"},{"title":"HttpUriConflict Validation - Open​","type":1,"pageTitle":"Known Issues","url":"/smithy4s/docs/known-issues#httpuriconflict-validation---open","content":"Currently, the validator that checks for HttpUriConflict is overly constraining. This means that it currently reports conflicts between URIs where there is actually no conflict. For example, operations with the following two http traits currently report a conflict: @http(method: &quot;GET&quot;, uri: &quot;/hello&quot;) @http(method: &quot;GET&quot;, uri: &quot;/{name}/greet&quot;)  There is an issue open on the Smithy repository where you can track progress on this being resolved. ","version":"Next","tagName":"h2"},{"title":"Intro","type":0,"sectionRef":"#","url":"/smithy4s/docs/overview/intro","content":"Intro Smithy is an interface definition language (IDL) provided by AWS. It is protocol agnostic, flexible, and reasonably low surface, which facilitates the writing of tooling around it. Smithy4s is a tool that generates third-party-free, protocol-agnostic scala code from smithy specifications. Smithy4s can be used to: quickly derive http/rest servers and clientsderive pure-scala AWS clientsderive CLI toolsand has the potential for much, much more! Smithy4s supports both Smithy 2.0 and Smithy 1.0 models. You can read about the differences in this blogpost from AWS.","keywords":"","version":"Next"},{"title":"Installation","type":0,"sectionRef":"#","url":"/smithy4s/docs/overview/installation","content":"","keywords":"","version":"Next"},{"title":"SBT​","type":1,"pageTitle":"Installation","url":"/smithy4s/docs/overview/installation#sbt","content":"For mill support, see Mill below. smithy4s-sbt-codegen is a code generating sbt plugin that creates .scala files corresponding to the provided .smithy specs. In project/plugins.sbt: addSbtPlugin(&quot;com.disneystreaming.smithy4s&quot; % &quot;smithy4s-sbt-codegen&quot; % &quot;0.18.16&quot;)  and enable the plugin in the desired sbt module: import smithy4s.codegen.Smithy4sCodegenPlugin val myModule = project .in(file(&quot;modules/my-module&quot;)) .enablePlugins(Smithy4sCodegenPlugin) // version for smithy4s-core is sourced from Smithy4sCodegenPlugin .settings(libraryDependencies += &quot;com.disneystreaming.smithy4s&quot; %% &quot;smithy4s-core&quot; % smithy4sVersion.value)  This will enable the plugin on myModule. We also need to add smithy4s-core here since it is needed for compiling the generated code. By default, the plugin will look in the $MY_MODULE/src/main/smithy directory and will write scala code in $MY_MODULE/target/scala-&lt;version&gt;/src_managed/ when invoking compile. The paths are configurable via the smithy4sInputDirs and smithy4sOutputDir settings keys. For example, in order for the plugin to source .smithy specs from ./smithy_input (inside the folder where our build.sbt is) and output the generated files into ./smithy_output. val myModule = project .in(file(&quot;modules/my-module&quot;)) .enablePlugins(Smithy4sCodegenPlugin) .settings( scalaVersion := &quot;2.13.12&quot;, Compile / smithy4sInputDirs := Seq((ThisBuild / baseDirectory).value / &quot;smithy_input&quot;), Compile / smithy4sOutputDir := (ThisBuild / baseDirectory).value / &quot;smithy_output&quot;, libraryDependencies += &quot;com.disneystreaming.smithy4s&quot; %% &quot;smithy4s-core&quot; % smithy4sVersion.value )  ","version":"Next","tagName":"h2"},{"title":"Mill​","type":1,"pageTitle":"Installation","url":"/smithy4s/docs/overview/installation#mill","content":"smithy4s-mill-codegen-plugin is a plugin to enable Smithy4s code generation on a mill module. For example, here, we enabled it on the example module: import $ivy.`com.disneystreaming.smithy4s::smithy4s-mill-codegen-plugin::0.18.16` import smithy4s.codegen.mill._ import mill._, mill.scalalib._ object example extends ScalaModule with Smithy4sModule { def scalaVersion = &quot;2.13.8&quot; override def ivyDeps = Agg( ivy&quot;com.disneystreaming.smithy4s::smithy4s-core:${smithy4sVersion()}&quot; ) }  By default, the mill plugin will look for Smithy files under the $MY_MODULE/smithy directory. The generated code ends up in out/$MY_MODULE/smithy4sOutputDir.dest/scala/, again, by default. Code generation happens automatically when you before you compile the module. The paths are configurable via the smithy4sInputDirs and smithy4sOutputDir tasks. For example, here we'll read Smithy files from smithy_input and write to smithy_output. import $ivy.`com.disneystreaming.smithy4s::smithy4s-mill-codegen-plugin::0.18.16` import smithy4s.codegen.mill._ import mill._, mill.scalalib._ object example extends ScalaModule with Smithy4sModule { def scalaVersion = &quot;2.13.8&quot; override def ivyDeps = Agg( ivy&quot;com.disneystreaming.smithy4s::smithy4s-core:${smithy4sVersion()}&quot; ) override def smithy4sInputDirs = T.sources { Seq(PathRef(T.ctx().workspace / &quot;smithy_input&quot;)) } override def smithy4sOutputDir = T { PathRef(T.ctx().workspace / &quot;smithy_output&quot;) } }  ","version":"Next","tagName":"h2"},{"title":"Installation (CLI)","type":0,"sectionRef":"#","url":"/smithy4s/docs/overview/cli","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Installation (CLI)","url":"/smithy4s/docs/overview/cli#installation","content":"cs install --channel https://disneystreaming.github.io/coursier.json smithy4s  ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"Installation (CLI)","url":"/smithy4s/docs/overview/cli#usage","content":"The CLI comes with a number of options to customize output directories, skip openapi generation (or scala generation), provide a filter of allowed namespaces, etc. Use the --help command to get an exhaustive listing. bash&gt; smithy4s --help Usage: smithy4s generate smithy4s dump-model smithy4s version Command line interface for Smithy4s Options and flags: --help Display this help text. Subcommands: generate Generates scala code and openapi-specs from smithy specs dump-model Output a JSON view of the Smithy models version Output the version of the CLI.  Codegen​ bash&gt; smithy4s generate --help Usage: generate [--output &lt;path&gt;] [--resource-output &lt;path&gt;] [--skip &lt;string&gt;]... [--discover-models] [--allowed-ns &lt;string,string,...&gt;] [--excluded-ns &lt;string,string,...&gt;] [--repositories &lt;string,string,...&gt;] [--dependencies &lt;string,string,...&gt;] [--transformers &lt;string,string,...&gt;] [--local-jars &lt;path,path,...&gt;] [&lt;path&gt;...] Generates scala code and openapi-specs from smithy specs Options and flags: --help Display this help text. --output &lt;path&gt;, -o &lt;path&gt; Path where scala code should be generated. Defaults to pwd --resource-output &lt;path&gt; Path where non-scala files should be generated. Defaults to pwd --skip &lt;string&gt; Indicates that some files types should be skipped during generation --discover-models Indicates whether the model assembler should try to discover models in the classpath --allowed-ns &lt;string,string,...&gt; Comma-delimited list of namespaces that should not be processed. If unset, all namespaces are processed (except stdlib ones) --excluded-ns &lt;string,string,...&gt; Comma-delimited list of namespaces that should not be processed. If unset, all namespaces are processed (except stdlib ones) --repositories &lt;string,string,...&gt; Comma-delimited list of repositories to look in for resolving any provided dependencies --dependencies &lt;string,string,...&gt; Comma-delimited list of dependencies containing smithy files --transformers &lt;string,string,...&gt; Comma-delimited list of transformer names to apply to smithy files --local-jars &lt;path,path,...&gt; Comma-delimited list of local JAR files containing smithy files  Dump model​ bash&gt; smithy4s dump-model --help Usage: dump-model [--repositories &lt;string,string,...&gt;] [--dependencies &lt;string,string,...&gt;] [--transformers &lt;string,string,...&gt;] [--local-jars &lt;path,path,...&gt;] [&lt;path&gt;...] Output a JSON view of the Smithy models Options and flags: --help Display this help text. --repositories &lt;string,string,...&gt; Comma-delimited list of repositories to look in for resolving any provided dependencies --dependencies &lt;string,string,...&gt; Comma-delimited list of dependencies containing smithy files --transformers &lt;string,string,...&gt; Comma-delimited list of transformer names to apply to smithy files --local-jars &lt;path,path,...&gt; Comma-delimited list of local JAR files containing smithy files  ","version":"Next","tagName":"h3"},{"title":"Smithy4s Transformations and generalisation","type":0,"sectionRef":"#","url":"/smithy4s/docs/guides/smithy4s-transformations","content":"","keywords":"","version":"Next"},{"title":"Error-related transformations​","type":1,"pageTitle":"Smithy4s Transformations and generalisation","url":"/smithy4s/docs/guides/smithy4s-transformations#error-related-transformations","content":"Using transformations, it is possible to surface errors into the context a service operates, or, in the contrary, to absorb errors to make them disappear from the context. The generated interfaces contain the accurate information associated to each method, and the companion objects contain the necessary constructs to transform typed-errors into throwables and to recover type-errors from throwables. $version: &quot;2&quot; namespace smithy4s.example service KVStore { operations: [Get, Put, Delete], errors: [UnauthorizedError] } operation Put { input: KeyValue } operation Get { input: Key, output: Value, errors: [KeyNotFoundError] } operation Delete { input: Key, errors: [KeyNotFoundError] } structure Key { @required key: String } structure KeyValue { @required key: String, @required value: String } structure Value { @required value: String } @error(&quot;client&quot;) structure UnauthorizedError { @required reason: String } @error(&quot;client&quot;) structure KeyNotFoundError { @required message: String }  ","version":"Next","tagName":"h2"},{"title":"Surfacing errors​","type":1,"pageTitle":"Smithy4s Transformations and generalisation","url":"/smithy4s/docs/guides/smithy4s-transformations#surfacing-errors","content":"The smithy4s.Transformation.SurfaceError interface codifies the transformation of service implementations from contexts that represent errors as a generic Throwable, from contexts that have the awareness of the errors specified in the specifications. It is useful when you want to exhaustively handle the errors that are specified (as opposed to letting them propagate). To make the ascription of such contexts easier, Smithy4s generates ErrorAware[F[_, _]] type aliases in the companion objects of services. This can be used conjointly with types that have &quot;two&quot; parameters, one for the error, one for the result. For instance type BIO[E, A] = EitherT[IO, E, A]. import smithy4s.example._ import smithy4s.example.KVStore import smithy4s.Transformation import scala.util.{Failure, Success, Try} object kvStoreTry extends KVStore[Try] { def delete(key: String): Try[Unit] = Success(()) def put(key: String, value: String): Try[Unit] = Success(()) def get(key: String): Failure[Value] = Failure(KeyNotFoundError(s&quot;Key $key wasn't found&quot;)) } // SurfaceError allows to go from mono-functor to bi-functor, for instance, from // IO[A] to EitherT[IO, E, A] val toEither: Transformation.SurfaceError[Try, Either] = new Transformation.SurfaceError[Try, Either] { def apply[E, A]( value: Try[A], catcher: Throwable =&gt; Option[E] ): Either[E, A] = value match { case Success(value) =&gt; Right(value) case Failure(error) =&gt; catcher(error) match { case None =&gt; throw error // don't do this at work! case Some(e) =&gt; Left(e) } } } // toEither: Transformation.SurfaceError[Try, Either] = repl.MdocSession$MdocApp$$anon$3@a9a2d6c val kvStoreEither: KVStore.ErrorAware[Either] = kvStoreTry.transform(toEither) // kvStoreEither: KVStore.ErrorAware[Either] = smithy4s.example.KVStoreOperation$Transformed@30d0567e val result: Either[KVStore.GetError, Value] = kvStoreEither.get(&quot;foo&quot;) // result: Either[KVStore.GetError, Value] = Left( // value = KeyNotFoundErrorCase( // keyNotFoundError = KeyNotFoundError(message = &quot;Key foo wasn't found&quot;) // ) // )  ","version":"Next","tagName":"h3"},{"title":"Absorbing errors​","type":1,"pageTitle":"Smithy4s Transformations and generalisation","url":"/smithy4s/docs/guides/smithy4s-transformations#absorbing-errors","content":"The smithy4s.Transformation.AbsorbErrors interface is the opposite as the SurfaceError: it codifies the absorption of errors known by the service into generic error channels. It is useful to implement services in a way that leverages the type-checker to ensure that the returned errors have been specified in Smithy, before passing the implementation to a generic router that is only able to work against a monofunctor. import smithy4s.example._ import smithy4s.example.KVStore import smithy4s.Transformation import scala.util.{Failure, Success, Try} object kvStoreEither extends KVStore.ErrorAware[Either] { def delete(key: String): Either[KVStore.DeleteError, Unit] = Right(()) def put(key: String, value: String): Either[Nothing, Unit] = Right(()) def get(key: String): Either[KVStore.GetError, Value] = Left( KVStore.GetError.KeyNotFoundErrorCase( KeyNotFoundError(s&quot;Key $key wasn't found&quot;) ) ) } val toTry: Transformation.AbsorbError[Either, Try] = new Transformation.AbsorbError[Either, Try] { def apply[E, A]( value: Either[E, A], thrower: E =&gt; Throwable ): Try[A] = value match { case Left(error) =&gt; Failure(thrower(error)) case Right(value) =&gt; Success(value) } } // toTry: Transformation.AbsorbError[Either, Try] = repl.MdocSession$MdocApp3$$anon$4@64310031 val kvStoreTry: KVStore[Try] = kvStoreEither.transform(toTry) // kvStoreTry: KVStore[Try] = smithy4s.example.KVStoreOperation$Transformed@766fe66d val result: Try[Value] = kvStoreTry.get(&quot;foo&quot;) // result: Try[Value] = Failure( // exception = KeyNotFoundError(message = &quot;Key foo wasn't found&quot;) // )  ","version":"Next","tagName":"h3"},{"title":"Stubbed implementations","type":0,"sectionRef":"#","url":"/smithy4s/docs/overview/stubs","content":"Stubbed implementations For various reasons, such as testing/mocking, you may want to instantiate a stub implementation of generated service interfaces. Smithy4s makes it easy, by generating a Default class in the companion object of each service. This class has a constructor parameter that requires a value. This value is what is returned when invoking any of the methods import smithy4s.example.hello._ import cats.effect._ val stubbedHelloWorld: HelloWorldService[IO] = new HelloWorldService.Default[IO](IO.stub) Obviously, the generated methods can be overridden. import smithy4s.example.hello._ import cats.effect._ val overriddenHelloWorld: HelloWorldService[IO] = new HelloWorldService.Default[IO](IO.stub){ override def hello(name: String, town: Option[String]): IO[Greeting] = IO.pure { Greeting(s&quot;Hello $name!&quot;) } } NB it is important to ascribe the type of the stubbed instance when using this feature.","keywords":"","version":"Next"},{"title":"Quick Start","type":0,"sectionRef":"#","url":"/smithy4s/docs/overview/quickstart","content":"","keywords":"","version":"Next"},{"title":"For sbt​","type":1,"pageTitle":"Quick Start","url":"/smithy4s/docs/overview/quickstart#for-sbt","content":"This section will get you started with a simple sbt module that enables smithy4s code generation. For a similar setup for mill, see Mill below. ","version":"Next","tagName":"h2"},{"title":"project/plugins.sbt​","type":1,"pageTitle":"Quick Start","url":"/smithy4s/docs/overview/quickstart#projectpluginssbt","content":"Add the smithy4s-sbt-codegen plugin to your build. addSbtPlugin(&quot;com.disneystreaming.smithy4s&quot; % &quot;smithy4s-sbt-codegen&quot; % &quot;0.18.16&quot;)  ","version":"Next","tagName":"h3"},{"title":"build.sbt​","type":1,"pageTitle":"Quick Start","url":"/smithy4s/docs/overview/quickstart#buildsbt","content":"Enable the plugin in your project, add the smithy and http4s dependencies. import smithy4s.codegen.Smithy4sCodegenPlugin ThisBuild / scalaVersion := &quot;2.13.12&quot; val example = project .in(file(&quot;modules/example&quot;)) .enablePlugins(Smithy4sCodegenPlugin) .settings( libraryDependencies ++= Seq( &quot;com.disneystreaming.smithy4s&quot; %% &quot;smithy4s-http4s&quot; % smithy4sVersion.value, &quot;com.disneystreaming.smithy4s&quot; %% &quot;smithy4s-http4s-swagger&quot; % smithy4sVersion.value, &quot;org.http4s&quot; %% &quot;http4s-ember-server&quot; % &quot;0.23.26&quot; ) )  ","version":"Next","tagName":"h3"},{"title":"For Mill​","type":1,"pageTitle":"Quick Start","url":"/smithy4s/docs/overview/quickstart#for-mill","content":"This section will get you started with a mill module with code generation enabled on it. In your build.sc: import $ivy.`com.disneystreaming.smithy4s::smithy4s-mill-codegen-plugin::0.18.16` import smithy4s.codegen.mill._ import mill._, mill.scalalib._ object example extends ScalaModule with Smithy4sModule { def scalaVersion = &quot;2.13.8&quot; override def ivyDeps = Agg( ivy&quot;com.disneystreaming.smithy4s::smithy4s-core:${smithy4sVersion()}&quot;, ivy&quot;com.disneystreaming.smithy4s::smithy4s-http4s-swagger:${smithy4sVersion()}&quot;, ivy&quot;org.http4s::http4s-ember-server:0.23.26&quot; ) }  ","version":"Next","tagName":"h2"},{"title":"Smithy content​","type":1,"pageTitle":"Quick Start","url":"/smithy4s/docs/overview/quickstart#smithy-content","content":"Now is the time to add some Smithy shapes to see what code generation can do for you. Following the setup above, the location for the Smithy content will change depending on what build tool you used. Now let's define an API in Smithy. Create the following file: for sbt, you'll write in modules/example/src/main/smithy/ExampleService.smithy.for mill, you'll write in example/smithy/ExampleService.smithy And add the content below: namespace smithy4s.hello use alloy#simpleRestJson @simpleRestJson service HelloWorldService { version: &quot;1.0.0&quot;, operations: [Hello] } @http(method: &quot;POST&quot;, uri: &quot;/{name}&quot;, code: 200) operation Hello { input: Person, output: Greeting } structure Person { @httpLabel @required name: String, @httpQuery(&quot;town&quot;) town: String } structure Greeting { @required message: String }  The Scala code corresponding to this smithy file will be generated the next time you compile your project. ","version":"Next","tagName":"h2"},{"title":"Using the generated code​","type":1,"pageTitle":"Quick Start","url":"/smithy4s/docs/overview/quickstart#using-the-generated-code","content":"Now, let's use the generated code by the service. You need to create a scala file at the following location: for sbt modules/example/src/main/scala/Main.scalafor mill example/src/Main.scala Implement your service by extending the generated Service trait. Wire up routes into server. import smithy4s.example.hello._ import cats.effect._ import cats.implicits._ import org.http4s.implicits._ import org.http4s.ember.server._ import org.http4s._ import com.comcast.ip4s._ import smithy4s.http4s.SimpleRestJsonBuilder object HelloWorldImpl extends HelloWorldService[IO] { def hello(name: String, town: Option[String]): IO[Greeting] = IO.pure { town match { case None =&gt; Greeting(s&quot;Hello $name!&quot;) case Some(t) =&gt; Greeting(s&quot;Hello $name from $t!&quot;) } } } object Routes { private val example: Resource[IO, HttpRoutes[IO]] = SimpleRestJsonBuilder.routes(HelloWorldImpl).resource private val docs: HttpRoutes[IO] = smithy4s.http4s.swagger.docs[IO](HelloWorldService) val all: Resource[IO, HttpRoutes[IO]] = example.map(_ &lt;+&gt; docs) } object Main extends IOApp.Simple { val run = Routes.all .flatMap { routes =&gt; EmberServerBuilder .default[IO] .withPort(port&quot;9000&quot;) .withHost(host&quot;localhost&quot;) .withHttpApp(routes.orNotFound) .build } .use(_ =&gt; IO.never) }  ","version":"Next","tagName":"h2"},{"title":"Run Service​","type":1,"pageTitle":"Quick Start","url":"/smithy4s/docs/overview/quickstart#run-service","content":"for sbt: sbt &quot;example/run&quot;for mill: mill example.run ","version":"Next","tagName":"h2"},{"title":"Navigate to localhost:9000/docs​","type":1,"pageTitle":"Quick Start","url":"/smithy4s/docs/overview/quickstart#navigate-to-localhost9000docs","content":"Here you will find the automatically generated SwaggerUI which will allow you to easily test your API.   ","version":"Next","tagName":"h2"},{"title":"Client Example​","type":1,"pageTitle":"Quick Start","url":"/smithy4s/docs/overview/quickstart#client-example","content":"You can also generate a client using smithy4s. import org.http4s.ember.client.EmberClientBuilder object ClientImpl extends IOApp.Simple { val helloWorldClient: Resource[IO, HelloWorldService[IO]] = for { client &lt;- EmberClientBuilder.default[IO].build helloClient &lt;- SimpleRestJsonBuilder(HelloWorldService) .client(client) .uri(Uri.unsafeFromString(&quot;http://localhost:9000&quot;)) .resource } yield helloClient val run = helloWorldClient.use(c =&gt; c.hello(&quot;Sam&quot;, Some(&quot;New York City&quot;)) .flatMap(greeting =&gt; IO.println(greeting.message)) ) }  ","version":"Next","tagName":"h2"},{"title":"Alloy","type":0,"sectionRef":"#","url":"/smithy4s/docs/protocols/alloy","content":"","keywords":"","version":"Next"},{"title":"What does Alloy contain?​","type":1,"pageTitle":"Alloy","url":"/smithy4s/docs/protocols/alloy#what-does-alloy-contain","content":"Alloy is a place that contains generic Smithy shapes that are commonly used across multiple projects. This includes things such as UUID, untagged, discriminated, etc. See Alloy documentation for more information about the shapes it contains. ","version":"Next","tagName":"h2"},{"title":"Why Alloy?​","type":1,"pageTitle":"Alloy","url":"/smithy4s/docs/protocols/alloy#why-alloy","content":"As mentioned above, having a common place where we publish shapes reduces the amount of duplication across our different projects (such as smithy4s and smithy-translate). Further, having more common shapes reduces the number of transformations that need to be done when using shapes in various projects. This simplifies the development efforts of anyone involved with creating smithy-based tooling. ","version":"Next","tagName":"h2"},{"title":"Migration from smithy4s.api​","type":1,"pageTitle":"Alloy","url":"/smithy4s/docs/protocols/alloy#migration-from-smithy4sapi","content":"Alloy was introduced in Q4 of 2022. Prior to this, smithy4s used its own protocol called smithy4s.api#simpleRestJson. Migrating from smithy4s.api#simpleRestJson to alloy#simpleRestJson should be trivial. The shapes have retained their semantics and use the same validation as prior. You should be able to just change smithy4s.api to alloy in your Smithy files and be good to go. If you run into any issues, reach out to us in GitHub discussions or issues. ","version":"Next","tagName":"h2"},{"title":"Sharing specifications","type":0,"sectionRef":"#","url":"/smithy4s/docs/overview/sharing-specs","content":"","keywords":"","version":"Next"},{"title":"Scala-agnostic context​","type":1,"pageTitle":"Sharing specifications","url":"/smithy4s/docs/overview/sharing-specs#scala-agnostic-context","content":"If you work in a context that is not primordially Scala-centric, you may want to package Smithy specification in Jars to make them easily accessible to various code-generator tools. When that is the case, it is not-advised to use Smithy4s in order to package specifications, as the consuming applications/tools might not have awareness of Scala. The best practice would likely be to have jars that would contain only Smithy files and potentially pure-java custom validators. In order to package Smithy files in jars so that they can be easily consumed by tools, here are the core details: All smithy files should be stored under src/main/resources/META-INF/smithy/ (or in another resource directory, under META-INF/smithy)A manifest file should be stored under that same directoryThe manifest file should reference all the smithy files that can be found in that META-INF/smithy directory.If you are using SBT to do this, consider setting autoScalaLibrary := false. See here for more information.If you are using Mill to do this, consider using a JavaModule instead of a ScalaModule. A couple examples: smithy-aws-apigateway-traitssmithy4s-protocols ","version":"Next","tagName":"h2"},{"title":"Smithy4s-context​","type":1,"pageTitle":"Sharing specifications","url":"/smithy4s/docs/overview/sharing-specs#smithy4s-context","content":"The Smithy4s build-plugins we provide out of the box automatically package the local specifications (used for code-generations) in the resulting jars so that downstream projects (internal and external) can use them. When doing so, Smithy4s abides by the same structure described above. Additionally, Smithy4s will also produce a smithy file containing a piece of metadata listing the namespaces for which code was generated. This way, downstream Smithy4s calls can automatically skip the already-generated namespaces. This does mean two things: Users do not have to manually indicate namespaces that were already generated.When using multi-module builds, Smithy specifications in one module can depend on Smithy specifications in another module it depends on, without the user having to do anything bespoke for it. The resulting Scala code in the downstream module will simply depend on the one in the upstream module, as if it had been handwritten. ","version":"Next","tagName":"h2"},{"title":"Disabling packaging of smithy files in jars​","type":1,"pageTitle":"Sharing specifications","url":"/smithy4s/docs/overview/sharing-specs#disabling-packaging-of-smithy-files-in-jars","content":"If for some reason you want to disable the packaging of Smithy files in the jars created by your build tool, follow the instructions below. SBT​ Add the following setting to your project Compile / smithy4sSmithyLibrary := false  Mill​ Override the following method in your module override def smithy4sSmithyLibrary = T(false)  ","version":"Next","tagName":"h3"},{"title":"Disabling the dependency on smithy files in sibling projects​","type":1,"pageTitle":"Sharing specifications","url":"/smithy4s/docs/overview/sharing-specs#disabling-the-dependency-on-smithy-files-in-sibling-projects","content":"If your project has a multi-module build and some of the modules have the plugin enabled, due to the behavior documented above, dependencies will need to be compiled before code can be generated. Consider the following build (sbt syntax): val a = project val b = project.enablePlugin(Smithy4sCodegenPlugin).dependsOn(a)  Whenever you want to generate the Scala code in project b, your build tool will trigger compilation of a. This happens so that the Smithy files in the a project get packaged into a JAR file - just like they normally are when you package the a project otherwise (for publishLocal, stage etc.). You can opt out of this behavior: SBT​ val b = project.settings( Compile / smithy4sInternalDependenciesAsJars := Nil )//...  Mill​ object b extends Smithy4sModule { //... override def smithy4sInternalDependenciesAsJars = List.empty[PathRef] }  This will not only remove the need for compilation (for the purposes of codegen), but also remove any visibility of the Smithy files in the local dependencies of your project (local meaning they're defined in the same build). You can use the same setting, smithy4sInternalDependenciesAsJars, to add additional JARs containing Smithy specs - just keep in mind that remote dependencies (libraryDependencies) are added automatically! ","version":"Next","tagName":"h3"},{"title":"A word of warning​","type":1,"pageTitle":"Sharing specifications","url":"/smithy4s/docs/overview/sharing-specs#a-word-of-warning","content":"Smithy4s optimises for &quot;correctness&quot; as opposed to &quot;compatibility.&quot; This means the generated Scala code aims at 1) being an accurate reflection of the Smithy models and 2) providing an idiomatic developer experience. This happens at the cost of a lack of guarantees around the binary compatibility of the generated code when the Schema evolves. When packaging Smithy specs in artifacts that contain Smithy4s-generated code, developers should keep that aspect in mind, and ensure that the version of Smithy4s that produced upstream artifacts is binary-compatible with the version that they use locally. Tools such as MiMa can help We cannot recommend treating Smithy4s-generated code as publishable library-material. Should you decide to do so, please exercise caution. Depending on shared specifications ","version":"Next","tagName":"h3"},{"title":"Artifacts containing only specifications​","type":1,"pageTitle":"Sharing specifications","url":"/smithy4s/docs/overview/sharing-specs#artifacts-containing-only-specifications","content":"For instance, AWS publishes a number of api-gateway specific traits to Maven central (the shapes are defined there in a smithy-compliant Json file). ","version":"Next","tagName":"h2"},{"title":"SBT​","type":1,"pageTitle":"Sharing specifications","url":"/smithy4s/docs/overview/sharing-specs#sbt-2","content":"Using the SBT plugin, the Smithy4s config object can be used to tag dependencies that Smithy4s should feed to the code generator. You can declare your intent to depend on these smithy definitions as such: libraryDependencies += &quot;software.amazon.smithy&quot; % &quot;smithy-aws-iam-traits&quot; % &quot;1.14.1&quot; % Smithy4s  ","version":"Next","tagName":"h2"},{"title":"Mill​","type":1,"pageTitle":"Sharing specifications","url":"/smithy4s/docs/overview/sharing-specs#mill-2","content":"Mill uses a separate task to define dependencies that the code-generator should have awareness of: def smithy4sIvyDeps = Agg(ivy&quot;software.amazon.smithy::smithy-aws-iam-traits:1.14.1&quot;)  ","version":"Next","tagName":"h2"},{"title":"Consequence​","type":1,"pageTitle":"Sharing specifications","url":"/smithy4s/docs/overview/sharing-specs#consequence","content":"This will have the effect of loading the contents of the smithy files (or smithy-compliant Json files) from the artifact into the aggregated model that Smithy4s uses as an input to the code generator. It means that the traits and shapes defined in these files will be available to use in your models, but it also means that Smithy4s will try to generate code for these shapes. This artifact will not be included as a dependency to your project at compile-time (nor runtime), it will only be consumed for the Smithy specs (and validators) it may contain. ","version":"Next","tagName":"h2"},{"title":"Artifacts containing both Smithy files and Smithy4s generated code​","type":1,"pageTitle":"Sharing specifications","url":"/smithy4s/docs/overview/sharing-specs#artifacts-containing-both-smithy-files-and-smithy4s-generated-code","content":"When using Smithy4s, you may want to depend on artifacts that may have been built using Smithy4s, containing both Smithy specifications and generated Scala code (or rather, JVM bytecode resulting from the compilation of generated Scala code). In this case, you don't have to do anything particular, the simple fact of declaring a library dependency will result in the smithy files contained by that dependency to be used during the &quot;compilation&quot; of your smithy specs during the code-generation process. ","version":"Next","tagName":"h2"},{"title":"SBT​","type":1,"pageTitle":"Sharing specifications","url":"/smithy4s/docs/overview/sharing-specs#sbt-3","content":"libraryDependencies += &quot;organisation&quot; % &quot;artifact&quot; % &quot;version&quot;  ","version":"Next","tagName":"h3"},{"title":"Mill​","type":1,"pageTitle":"Sharing specifications","url":"/smithy4s/docs/overview/sharing-specs#mill-3","content":"def ivyDeps = T(Agg(ivy&quot;organisation:artifact:version&quot;))  ","version":"Next","tagName":"h3"},{"title":"Consequence​","type":1,"pageTitle":"Sharing specifications","url":"/smithy4s/docs/overview/sharing-specs#consequence-1","content":"Because the upstream usage of Smithy4s will have resulted in the creation of metadata tracking the namespaces that were already generated, the &quot;local&quot; Smithy4s code-generation will automatically skip the generation of code that should not be generated again. ","version":"Next","tagName":"h3"},{"title":"Artifacts containing Smithy4s generated code: dependency tracking​","type":1,"pageTitle":"Sharing specifications","url":"/smithy4s/docs/overview/sharing-specs#artifacts-containing-smithy4s-generated-code-dependency-tracking","content":"When packaging a project/module via SBT or Mill, Smithy4s adds a line to the Jar manifest of the project, informing downstream projects of library dependencies that may have been used during the code-generation of this project/module (ie, the dependencies annotated with % Smithy4s in SBT, and the ones provided bysmithy4sIvyDeps in mill). This information is used automatically by downstream projects using Smithy4s, which automatically pulls additional jars that would be specified in this bit of metadata. So, for instance, if you have lazy val upstream = (project in file(&quot;foo&quot;)) .enablePlugins(Smithy4sCodegenPlugin) .settings( organization := &quot;foobar&quot;, version := &quot;0.0.1&quot;, libraryDependencies ++= Seq( &quot;software.amazon.smithy&quot; % &quot;smithy-aws-iam-traits&quot; % &quot;1.14.1&quot; % Smithy4s ) )  and publish this project to an artifact repository, the Jar manifest will contain a line with the relevant dependencies (comma separated if there are more than one) : smithy4sDependencies: software.amazon.smithy:smithy-aws-iam-traits:1.14.1  Using this artifact in a downstream project, for instance with : lazy val downstream = (project in file(&quot;foo&quot;)) .enablePlugins(Smithy4sCodegenPlugin) .settings( libraryDependencies ++= Seq( // compile/runtime dependency that contains Smithy4s-generated code but doesn't contain smithy files &quot;foobar&quot; %% &quot;upstream&quot; % &quot;0.0.1&quot; ) )  will result in the &quot;software.amazon.smithy&quot; % &quot;smithy-aws-iam-traits&quot; % &quot;1.14.1&quot; dependency being automatically fetched and used for the smithy-level classpath of the smithy files contained by downstream. This effectively means that smithy files in downstream can use the Smithy shapes present in the smithy-aws-iam-traits artifact. One side-effect of this is that if you produce JARs containing artifacts produced by Smithy4s code generation, they'll contain some common files with other smithy projects, particularly within the META-INF folder. You'll need to write a custom assemblyMergeStrategy, like so: assemblyMergeStrategy := { case PathList(&quot;META-INF&quot;, xs @ _*) =&gt; xs.map(_.toLowerCase) match { // http4s-swagger provides the swagger webjar, which can conflict case &quot;resources&quot; :: &quot;webjars&quot; :: xs =&gt; MergeStrategy.first // There is no harm in removing the tracking file case &quot;smithy&quot; :: &quot;smithy4s.tracking.smithy&quot; =&gt; MergeStrategy.discard // Keep the correct smithy manifest case &quot;smithy&quot; :: &quot;manifest&quot; =&gt; MergeStrategy.first // Discard the rest case _ =&gt; MergeStrategy.discard } case x =&gt; val oldStrategy = assemblyMergeStrategy.value oldStrategy(x) }  This is perfectly fine to discard this file from your assembly jar. ","version":"Next","tagName":"h2"},{"title":"Manually skipping (or including) namespaces during code-generation.​","type":1,"pageTitle":"Sharing specifications","url":"/smithy4s/docs/overview/sharing-specs#manually-skipping-or-including-namespaces-during-code-generation","content":"Sometimes, you may want to tell Smithy4s to skip code-generation of some namespaces altogether, because the corresponding code may have been produced by another tool than Smithy4s. In that case, you can gain control over which namespaces Smithy4s crawls through when performing the code generation to avoid regenerating code that already exists. This is achieved via a couple of build-settings (the names are shared between SBT and Mill). smithy4sAllowedNamespaces which is an allow-listsmithy4sExcludedNamespaces which is a disallow-list By default, Smithy4s tries to generate everything but shapes that are in the following namespaces: smithy4s.apismithy4s.metaalloynamespaces that start with awsnamespaces that start with smithy ","version":"Next","tagName":"h3"},{"title":"Note regarding credentials​","type":1,"pageTitle":"Sharing specifications","url":"/smithy4s/docs/overview/sharing-specs#note-regarding-credentials","content":"The SBT plugin provided by Smithy4s uses SBT's resolution mechanism (based on coursier) to retrieve the artifacts from their respective repositories. This implies that the resolvers-related settings are respected, included credentials that may be needed to read from some private artifact repository. In the CLI, the mechanisms native to coursier are respected. ","version":"Next","tagName":"h3"},{"title":"Localstack","type":0,"sectionRef":"#","url":"/smithy4s/docs/protocols/aws/localstack","content":"","keywords":"","version":"Next"},{"title":"Implementation​","type":1,"pageTitle":"Localstack","url":"/smithy4s/docs/protocols/aws/localstack#implementation","content":"In order to target an Smithy4s-built AWS client to a local environment, you need to create a middleware (ie a Client[F] =&gt; Client[F] function) that redirects requests to the Localstack host and port. Here's an example import cats.effect._ import cats.syntax.all._ import com.amazonaws.dynamodb._ import fs2.io.net.Network import org.http4s.client.Client import org.http4s.ember.client.EmberClientBuilder import fs2.compression.Compression import org.http4s._ import org.typelevel.ci._ import smithy4s.aws._ import smithy4s.aws.kernel.AwsRegion object LocalstackProxy { def apply[F[_]: Async: Compression](client: Client[F]): Client[F] = Client { req =&gt; client.run( req.withUri( req.uri.copy(authority = req.uri.authority.map(x =&gt; x.copy( host = Uri.RegName(&quot;localhost&quot;), port = Some(4566) ) ) ) ) .putHeaders(Header.Raw(ci&quot;host&quot;, &quot;localhost&quot;)) ) } } object LocalstackDynamoDB { def env[F[_]: Async: Compression](client: Client[F], region: AwsRegion): AwsEnvironment[F] = AwsEnvironment.make[F]( client, Async[F].pure(region), Async[F].pure(AwsCredentials.Default(&quot;mock-key-id&quot;, &quot;mock-secret-key&quot;, None)), Async[F].realTime.map(_.toSeconds).map(Timestamp(_, 0)) ) def client[F[_]: Async: Network: Compression](client: Client[F], region: AwsRegion): Resource[F, DynamoDB.Impl[F]] = AwsClient(DynamoDB.service, env[F](LocalstackProxy[F](client), region)) } def myResource[F[_]: Async: Network: Compression] = for { underlying &lt;- EmberClientBuilder .default[F] .withoutCheckEndpointAuthentication .build client &lt;- LocalstackDynamoDB.client[F](underlying, AwsRegion.US_EAST_1) } yield client  ","version":"Next","tagName":"h3"},{"title":"Middlewares","type":0,"sectionRef":"#","url":"/smithy4s/docs/protocols/aws/middleware","content":"Middlewares It is not the purpose of Smithy4s to reach feature-parity with the official Java SDK, in particular when it comes to retry policies and metrics. However, it's important for Smithy4s to empower users to wire custom behaviour in the AWS clients it provides. To that end, Smithy4s provides a middleware mechanism : import smithy4s._ import smithy4s.aws._ import cats.effect._ import cats.syntax.all._ import org.http4s.client._ def http4sClient : Client[IO] = ??? object PrintingMiddleware extends Endpoint.Middleware.Standard[Client[IO]] { def prepare(serviceId: ShapeId, endpointId: ShapeId, serviceHints: Hints, endpointHints: Hints): Client[IO] =&gt; Client[IO] = underlyingClient =&gt; Client { req =&gt; IO.println(s&quot;Calling ${serviceId.name}.${endpointId.name}&quot;).toResource *&gt; underlyingClient.run(req) } } val awsEnvironment = AwsEnvironment.default(http4sClient, AwsRegion.US_EAST_1).map(_.withMiddleware(PrintingMiddleware)) The Endpoint.Middleware interface allows to provide transformations that will be applied on per-endpoint basis, allowing to customise the behaviour of the client based on the calls that are made to AWS.","keywords":"","version":"Next"},{"title":"Deriving CLIs","type":0,"sectionRef":"#","url":"/smithy4s/docs/protocols/deriving-cli","content":"Deriving CLIs The Smithy4s Decline module provides the capability to derive a Decline Cli for your service.The cli generated will be in the form of a Command[F[Unit]] where F is the effect type of your service.This module is written in Tagless Final style and requires an F[_] for which there is an instance of cats.MonadThrowLet's revisit our HelloWorld smithy definition from the Quickstart namespace smithy4s.hello use alloy#simpleRestJson @simpleRestJson service HelloWorldService { version: &quot;1.0.0&quot;, operations: [Hello] } @http(method: &quot;POST&quot;, uri: &quot;/{name}&quot;, code: 200) operation Hello { input: Person, output: Greeting } structure Person { @httpLabel @required name: String, @httpQuery(&quot;town&quot;) town: String } structure Greeting { @required message: String } Let's implement the HelloWorld service, we will use cats.effect.IO for our effect type. import smithy4s.example.hello._ import cats.effect.IO object HelloWorldServiceInstance{ val simple = new HelloWorldService[IO]{ def hello(name: String, town: Option[String]): IO[Greeting] = { IO { Greeting(s&quot;hello $name , who hails from $town&quot;) } } } } Now Using the decline module from Smithy4s we can wrap the service instance in an instance of a Smithy4sCli. The Smithy4sCli allows the customization of the Opts and stdin/stdout/stderr handling There is a convenient helper method Smithy4sCli.standalone to make it easier to construct Cli's using defaults.To utilize the helper method, wrap the service in an instance of Opts and pass it into Smithy4sCli.standalonethere are 2 methods available on the Smithy4sCli instance opts which will provide an Opts[F[Unit]] for the servicecommand which will provide a Command[F[Unit]] for the service. This uses defaults from the Smithy spec command name will use the service nameif documentation comments are available on the service , they will be used as the command help text import com.monovore.decline._ import smithy4s.decline.Smithy4sCli val serviceWrappedInOpts = Opts(HelloWorldServiceInstance.simple) val helloCommand: Command[IO[Unit]] = Smithy4sCli.standalone(serviceWrappedInOpts).command helloCommand is now a runnable Command that can parse command line args and returns an IO[Unit]We can implement a CLI that will run the command and print the result to stdout import smithy4s.decline.Smithy4sCli import cats.effect._ import com.monovore.decline._ import com.monovore.decline.effect.CommandIOApp object app extends IOApp { override def run(args: List[String]) = { val helloCommand: Command[IO[ExitCode]] = Smithy4sCli .standalone(Opts(HelloWorldServiceInstance.simple)) .command.map(_.redeem(_ =&gt; ExitCode.Error, _ =&gt; ExitCode.Success)) CommandIOApp.run(helloCommand, args) } } the command will provide the following interface Usage: hello-world-service hello [--output &lt;output&gt;] &lt;name&gt; [&lt;town&gt;] HTTP POST /{name} Options and flags: --help Display this help text. --output &lt;output&gt; Output mode Smithy to Decline mappings The Service name will be used to generate the top level Command All operations will be mapped to subcommands The Input structure is flattened to top level fields with no nesting All Primitives are mapped to a Positional decline Argument , with the following exceptions. Boolean fields are mapped to a decline FlagBlobs are mapped to take in either stdin(by passing in - ) or a full file path and will produce a Byte arrayTimestamps are parsed using TimestampFormat.DATE_TIME by default, but @timestampFormat can be used to customize that. Lists and recursive types a top level list is converted to a repeated positional argument (or flag in case of Boolean)All recursive types expect json to be passed in. How is Nesting handled all nested fields are converted to Optionsa nested list is converted to expect a json i.e. List[String] would expect '[&quot;foo&quot;,&quot;baz&quot;,&quot;qux&quot;]' as a decline Option when the nested list contains blobs , it will expect a json of base64 encoded strings Help Documentation is added to every field, operation and service - if available. For HTTP operations a path template is provided as well. Missing Features Collision Handling for un-nesting of nested fields","keywords":"","version":"Next"},{"title":"What is a Protocol?","type":0,"sectionRef":"#","url":"/smithy4s/docs/protocols/definition","content":"","keywords":"","version":"Next"},{"title":"TCP/IP​","type":1,"pageTitle":"What is a Protocol?","url":"/smithy4s/docs/protocols/definition#tcpip","content":"For starters, let's briefly address the protocols that exist at the lower layers of the internet and build from there. TCP/IP is a framework that organizes these various layers and the protocols therein. The layers are usually divided up, from lowest to highest, as follows: Network Access Layer​ This layer is used to refer to the hardware that exists to facilitate the connections and protocols at higher levels. In other words, this layer is concerned with the physical transmission of data from one place to another. Internet Layer​ This layer is mainly composed of the Internet Protocol. The Internet Protocol is what allows identifying and locating hosts on a network. The &quot;IP&quot; in &quot;IPv4&quot; and &quot;IPv6&quot; stands for &quot;Internet Protocol&quot; and those are two respective versions of that protocol. Transport Layer​ At this point live the TCP and UDP protocols. These protocols take two different approaches to the transferring of messages between two hosts. Application Layer​ Finally, at the top layer we have the protocol that we are all familiar with: http. Other examples of application-layer protocols are FTP, SSH, and SMTP. All of these protocols define their own procedures for interactions between host applications. Essentially, they are adding more structure to interactions that use TCP or UDP underneath. HTTP, for example, uses TCP to facilitate connections. Summary​ In summary, TCP/IP is a collection of protocols, grouped into layers, that make up the basis for interactions between computers. ","version":"Next","tagName":"h2"},{"title":"HTTP​","type":1,"pageTitle":"What is a Protocol?","url":"/smithy4s/docs/protocols/definition#http","content":"Before we move on, let's make sure we have a common understanding of what HTTP actually is. HTTP stands for HyperText Transfer Protocol. As mentioned above, it builds upon TCP to send messages between two hosts. The most important thing for us to understand here is what HTTP defines and what it does not define. HTTP defines semantics for communicating between host applications in a request-response model. We are all likely familiar with making an HTTP request and getting back a response. The most basic example of this is loading a web page on the internet. Below is a collection of things that HTTP DOES define. Note that we are not going to be exhaustive in our definition of HTTP. The below is just to give an overview. Request and Response Headers​ HTTP defines that each request and response may have headers which contain additional information related to the request or response. These are key-value pairs where the key is case-insensitive. Request Methods​ Requests have methods such as GET, PUT, POST, and DELETE (there are currently 9 total). These methods are intended to inform the destination application what the requester wishes to do with a given resource. Response Status Codes​ Responses in HTTP come with an integer status code that represents the category of the result of the request. For example a status code between 200 and 299 is used to indicate that a request was successful. Message Body​ HTTP defines that requests and responses each have an optional message body. This is usually where the majority of information is contained. Things NOT Defined in HTTP​ Now that we have covered the basis of what HTTP defines, it is important to call out a few things that it does not define. The most major thing left out of the HTTP specification is the format for data in the body of requests and responses. As far as HTTP is concerned, these bodies are just Bytes. Defining what these bodies look like is left to higher-level protocols (as we will discuss below). HTTP also does not define what types of resources requests should be able to work with. This means requests can be used to get or modify files stored in a system, in memory state, a third party API, or anything else one could imagine. Additionally, although HTTP provides some mechanisms for basic authentication, it does not define anything around authorization. Other protocols, such as OAuth 2.0 are often used with HTTP applications. REST vs HTTP​ Here is a quick note about REST since REST is often used interchangeably with HTTP despite the fact that they are two different things. REST stands for Representational State Transfer and is an architectural pattern. It is important to realize that REST is not backed by a strict RFC or other definition for what it means like HTTP is. As such, how the pattern is implemented varies throughout the industry. RESTful systems might use HTTP, but they don't need to. Similarly, HTTP services may be RESTful, but they don't need to be. The two are related, but are not the same and one does not require the other. ","version":"Next","tagName":"h2"},{"title":"High Level Protocols​","type":1,"pageTitle":"What is a Protocol?","url":"/smithy4s/docs/protocols/definition#high-level-protocols","content":"Here we will discuss several &quot;High Level Protocols.&quot; There isn't an official term for these, but we will coin them as such to differentiate them from the protocols discussed above. All of the following protocols build on top of HTTP (although they don't have to), but define different semantics on top of it. alloy#simpleRestJson​ The main protocol that we have defined for use in smithy4s is alloy#simpleRestJson. This protocol uses RESTful HTTP semantics and has HTTP bodies that are encoded as JSON. Essentially, this protocol is building on the various protocols we defined above, and just adding some constraints around how they are used. There are more constraints around how the JSON is encoded and a few other things which you can read about in full in the alloy documentation. gRPC​ gRPC is a framework for remote procedure calls. At the same time, we can consider it to be another protocol that is defined at the same level that alloy#simpleRestJson is defined. gRPC, in its current implementation, uses HTTP version 2 under the hood. It has additional definition around what the HTTP interactions look like such as the bodies being encoded with protocol buffers (protobuf). Additionally, all gRPC messages are sent with the HTTP POST method and use a specific header to specify which remote procedure is being invoked. There are quite a few other nuanced requirements for what makes up the gRPC protocol, but hopefully these few have showed you how gRPC builds on what HTTP provides to create a unique interaction pattern. AWS Protocols​ AWS themselves have defined quite a few protocols in Smithy. Examples of this range from aws.protocols#restJson1 which is very similar to alloy#simpleRestJson to aws.protocols#restXml. You can read more about these protocols in the Smithy documentation. ","version":"Next","tagName":"h2"},{"title":"Protocols in Smithy​","type":1,"pageTitle":"What is a Protocol?","url":"/smithy4s/docs/protocols/definition#protocols-in-smithy","content":"In the context of Smithy, a protocol is a set of concrete rules that define how data modelled in Smithy gets transcribed into lower-level semantics. A protocol definition in Smithy can be accompanied by a set of trait annotations which hold further information about how the Smithy shapes are transcribed. For example, the alloy#simpleRestJson protocol relies on the smithy.api#http trait annotation to provide information about which HTTP endpoint will map to each Smithy operation shape. Without the smithy.api#http trait, one would not be able to specify the protocol-specific semantics of an API. This is how Smithy, the language itself, is protocol agnostic while still allowing users to define APIs which conform to various protocols. How to Define a Protocol​ Protocols can be defined in Smithy as traits that are marked with the @protocolDefinition trait. For example, the (slightly simplified) definition of alloy#simpleRestJson looks like: namespace alloy @protocolDefinition() @trait(selector: &quot;service&quot;) structure simpleRestJson {}  This then allows you to annotate service shapes with the protocol. Although the protocol is defined in Smithy like this, the exact meaning of the protocol is defined elsewhere in documentation and more importantly in interpreters that implement the protocol (such as the interpreters that smithy4s uses to create http4s applications). Additionally, protocol definitions typically come with test cases, also defined in Smithy, which help to define the specific semantics of the protocol. ","version":"Next","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"What is a Protocol?","url":"/smithy4s/docs/protocols/definition#conclusion","content":"Hopefully, this article has helped to outline what a protocol is and more specifically what layers of protocols we are building upon to create something like the alloy#simpleRestJson protocol. If you have any more questions about protocols, especially the protocols we have defined and use in Smithy4s, don't hesitate to reach out. ","version":"Next","tagName":"h2"},{"title":"Compliance Tests","type":0,"sectionRef":"#","url":"/smithy4s/docs/protocols/compliance-tests","content":"","keywords":"","version":"Next"},{"title":"Example specification​","type":1,"pageTitle":"Compliance Tests","url":"/smithy4s/docs/protocols/compliance-tests#example-specification","content":"$version: &quot;2&quot; namespace smithy4s.example.test use smithy.test#httpRequestTests use smithy.test#httpResponseTests use alloy#simpleRestJson @simpleRestJson service HelloService { operations: [SayHello, Listen, TestPath] } @http(method: &quot;POST&quot;, uri: &quot;/&quot;) @httpRequestTests([ { id: &quot;say_hello&quot;, protocol: simpleRestJson, params: { &quot;greeting&quot;: &quot;Hi&quot;, &quot;name&quot;: &quot;Teddy&quot;, &quot;query&quot;: &quot;Hello there&quot; }, method: &quot;POST&quot;, uri: &quot;/&quot;, queryParams: [ &quot;Hi=Hello%20there&quot; ], headers: { &quot;X-Greeting&quot;: &quot;Hi&quot;, }, body: &quot;{\\&quot;name\\&quot;:\\&quot;Teddy\\&quot;}&quot;, bodyMediaType: &quot;application/json&quot; } ]) @httpResponseTests([ { id: &quot;say_hello&quot; protocol: simpleRestJson params: { payload: { result: &quot;Hello!&quot; }, header1: &quot;V1&quot; } body: &quot;{\\&quot;result\\&quot;:\\&quot;Hello!\\&quot;}&quot; headers: { &quot;X-H1&quot;: &quot;V1&quot;} code: 200 } ]) operation SayHello { input: SayHelloInput, output: SayHelloOutput errors: [SimpleError, ComplexError] } @input structure SayHelloInput { @httpHeader(&quot;X-Greeting&quot;) greeting: String, @httpQuery(&quot;Hi&quot;) query: String, name: String } structure SayHelloOutput { @required @httpPayload payload: SayHelloPayload @required @httpHeader(&quot;X-H1&quot;) header1: String } structure SayHelloPayload { @required result: String } @http(method: &quot;GET&quot;, uri: &quot;/listen&quot;) @readonly @httpRequestTests([ { id: &quot;listen&quot;, protocol: simpleRestJson, method: &quot;GET&quot;, uri: &quot;/listen&quot; } ]) operation Listen { } @http(method: &quot;GET&quot;, uri: &quot;/test-path/{path}&quot;) @readonly @httpRequestTests([ { id: &quot;TestPath&quot;, protocol: simpleRestJson, method: &quot;GET&quot;, uri: &quot;/test-path/sameValue&quot; params: { path: &quot;sameValue&quot; } } ]) operation TestPath { input := { @httpLabel @required path: String } } // The following shapes are used by the documentation @simpleRestJson service HelloWorldService { version: &quot;1.0.0&quot;, operations: [Hello] } @httpRequestTests([ { id: &quot;helloSuccess&quot; protocol: simpleRestJson method: &quot;POST&quot; uri: &quot;/World&quot; params: { name: &quot;World&quot; } }, { id: &quot;helloFails&quot; protocol: simpleRestJson method: &quot;POST&quot; uri: &quot;/fail&quot; params: { name: &quot;World&quot; } } ]) @http(method: &quot;POST&quot;, uri: &quot;/{name}&quot;, code: 200) operation Hello { input := { @httpLabel @required name: String }, output := { @required message: String } } @httpResponseTests([ { id: &quot;simple_error&quot; protocol: simpleRestJson params: { expected: -1 } code: 400 body: &quot;{\\&quot;expected\\&quot;:-1}&quot; bodyMediaType: &quot;application/json&quot; requireHeaders: [&quot;X-Error-Type&quot;] } ]) @error(&quot;client&quot;) structure SimpleError { @required expected: Integer } @httpResponseTests([ { id: &quot;complex_error&quot; protocol: simpleRestJson params: { value: -1, message: &quot;some error message&quot;, details: { date: 123, location: &quot;NYC&quot;} } code: 504 body: &quot;{\\&quot;value\\&quot;:-1,\\&quot;message\\&quot;:\\&quot;some error message\\&quot;,\\&quot;details\\&quot;:{\\&quot;date\\&quot;:123,\\&quot;location\\&quot;:\\&quot;NYC\\&quot;}}&quot; bodyMediaType: &quot;application/json&quot; requireHeaders: [&quot;X-Error-Type&quot;] }, { id: &quot;complex_error_no_details&quot; protocol: simpleRestJson params: { value: -1, message: &quot;some error message&quot; } code: 504 body: &quot;{\\&quot;value\\&quot;:-1,\\&quot;message\\&quot;:\\&quot;some error message\\&quot;}&quot; bodyMediaType: &quot;application/json&quot; requireHeaders: [&quot;X-Error-Type&quot;] } ]) @error(&quot;server&quot;) @httpError(504) structure ComplexError { @required value: Integer @required message: String details: ErrorDetails } structure ErrorDetails { @required @timestampFormat(&quot;epoch-seconds&quot;) date: Timestamp @required location: String }  We have a very simple specification: one operation with basic input and output shapes. We've added a httpRequestTests to define a compliance test for protocol implementors. ","version":"Next","tagName":"h2"},{"title":"Testing the protocol​","type":1,"pageTitle":"Compliance Tests","url":"/smithy4s/docs/protocols/compliance-tests#testing-the-protocol","content":"The service in the specification is annotated with the alloy#simpleRestJson protocol definition. We'll use the compliance-tests module to make sure this protocol can handle such an operation. Note: the following code and the compliance-tests module do not depend on a specific test framework. If you want to hook it into your test framework, it is easy to do so but it's outside the scope of this document. Refer to this example to see how we did it for Weaver in this project. First, some imports: import cats.effect._ import org.http4s._ import org.http4s.client.Client import smithy4s.compliancetests._ import smithy4s.example.test._ import smithy4s.http.HttpMediaType import smithy4s.http4s._ import smithy4s.kinds._ import smithy4s.Service import smithy4s.schema.Schema  Then, you can create and instance of ClientHttpComplianceTestCase and/or ServerHttpComplianceTestCase while selecting the protocol to use and the service to test: object SimpleRestJsonIntegration extends Router[IO] with ReverseRouter[IO] { type Protocol = alloy.SimpleRestJson val protocolTag = alloy.SimpleRestJson def expectedResponseType(schema: Schema[_]) = HttpMediaType(&quot;application/json&quot;) def routes[Alg[_[_, _, _, _, _]]]( impl: FunctorAlgebra[Alg, IO] )(implicit service: Service[Alg]): Resource[IO, HttpRoutes[IO]] = SimpleRestJsonBuilder(service).routes(impl).resource def reverseRoutes[Alg[_[_, _, _, _, _]]](app: HttpApp[IO],testHost: Option[String] = None)(implicit service: Service[Alg] ): Resource[IO, FunctorAlgebra[Alg, IO]] = { import org.http4s.implicits._ val baseUri = uri&quot;http://localhost/&quot; val suppliedHost = testHost.map(host =&gt; Uri.unsafeFromString(s&quot;http://$host&quot;)) SimpleRestJsonBuilder(service) .client(Client.fromHttpApp(app)) .uri(suppliedHost.getOrElse(baseUri)) .resource } } val tests: List[ComplianceTest[IO]] = HttpProtocolCompliance .clientAndServerTests(SimpleRestJsonIntegration, HelloWorldService)  Now, you can iterate over the test cases and do what you want. This is where you would hook in the test framework of your choice, but in the following example, we're just going to print the result: import cats.syntax.traverse._ import cats.effect.unsafe.implicits.global val runTests: IO[List[String]] = tests .map { tc =&gt; tc.run.map(_.toEither).map { case Left(value) =&gt; s&quot;Failed ${tc.show} with the following message: $value&quot; case Right(_) =&gt; s&quot;Success ${tc.show}&quot; } } .sequence  Will produce the following when executed: Success smithy4s.example.test#Hello(client|Request): helloSuccess Failed smithy4s.example.test#Hello(client|Request): helloFails with the following message: NonEmptyList(path test : the result value: \u001b[33mVector\u001b[39m(\u001b[32m&quot;World&quot;\u001b[39m) was not equal to the expected TestCase value \u001b[33mVector\u001b[39m(\u001b[32m&quot;fail&quot;\u001b[39m).) Success smithy4s.example.test#Hello(server|Request): helloSuccess Failed smithy4s.example.test#Hello(server|Request): helloFails with the following message: NonEmptyList( the result value: \u001b[33mHelloInput\u001b[39m(name = \u001b[32m&quot;fail&quot;\u001b[39m) was not equal to the expected TestCase value \u001b[33mHelloInput\u001b[39m(name = \u001b[32m&quot;World&quot;\u001b[39m).)  ","version":"Next","tagName":"h2"},{"title":"Protocols and Smithy4s","type":0,"sectionRef":"#","url":"/smithy4s/docs/protocols/protocols","content":"Protocols and Smithy4s The code generated by Smithy4s is strictly protocol agnostic, meaning that there is no particular processing to handle HTTP semantics, or JSON semantics in the generated code. Instead, Smithy4s relies on a number of highly polymorphic interfaces to communicate with the generated code, and derive JSON codecs out of it, or turn high level user provided code into HTTP services. But in theory, the same generated code can be used conjointly with other serialisation technologies (protobuf for instance) and protocols (gRPC). Protocol specific &quot;hints&quot; (called traits)can be added to the smithy models. Smithy4s accurately renders corresponding values, and allows for their retrieval via the polymorphic interfaces. This is how HTTP semantics can be derived from the generated code, for instance. Smithy4s is also not tied to any third-party library, and users could provide integrations with existing libraries on their own side, or come up with new interesting usecases. However, Smithy4s provides a few out-of-the-box integrations that are described in this section.","keywords":"","version":"Next"},{"title":"Protobuf","type":0,"sectionRef":"#","url":"/smithy4s/docs/protocols/protobuf-grpc/protobuf","content":"Protobuf For convenience, the smithy4s build plugins generate protobuf (.proto) definitions translated from smithy specifications out of the box. However, this translation is limited to the transitive closure of shapes that have the alloy.proto#protoEnabled or the alloy.proto#grpc traits. The location of these protobuf specifications is driven by the smithy4sResourceDir setting in SBT and the smithy4sResourceOutputDir in mill. The semantics of the smithy to protobuf translation are following the alloy specification.","keywords":"","version":"Next"},{"title":"The SimpleRestJson protocol","type":0,"sectionRef":"#","url":"/smithy4s/docs/protocols/simple-rest-json/overview","content":"","keywords":"","version":"Next"},{"title":"Semantics​","type":1,"pageTitle":"The SimpleRestJson protocol","url":"/smithy4s/docs/protocols/simple-rest-json/overview#semantics","content":"In this protocol, the values in shapes are bound to http metadata or body according to the specification of the Http Binding traits. However, the @mediaType trait has no incidence, and all bodies (when present) are serialised in JSON. ","version":"Next","tagName":"h2"},{"title":"Example spec​","type":1,"pageTitle":"The SimpleRestJson protocol","url":"/smithy4s/docs/protocols/simple-rest-json/overview#example-spec","content":"namespace smithy4s.example use alloy#simpleRestJson @simpleRestJson service HelloWorldService { version: &quot;1.0.0&quot; // Indicates that all operations in `HelloWorldService`, // here limited to the Hello operation, can return `GenericServerError`. errors: [GenericServerError] operations: [Hello] } @error(&quot;server&quot;) @httpError(500) structure GenericServerError { message: String } @http(method: &quot;POST&quot;, uri: &quot;/{name}&quot;, code: 200) operation Hello { input: Person output: Greeting } structure Person { @httpLabel @required name: String @httpQuery(&quot;town&quot;) town: String } structure Greeting { @required message: String }  ","version":"Next","tagName":"h2"},{"title":"Supported traits​","type":1,"pageTitle":"The SimpleRestJson protocol","url":"/smithy4s/docs/protocols/simple-rest-json/overview#supported-traits","content":"This protocol and its interpreters, are aware of the following traits provided out of the box: all simple shapescomposite data shapes, including collections, unions, structures.operations and servicesenumerationserror traithttp traitstimestampFormat trait For the full list, see below. ","version":"Next","tagName":"h2"},{"title":"Decoding and encoding unions​","type":1,"pageTitle":"The SimpleRestJson protocol","url":"/smithy4s/docs/protocols/simple-rest-json/overview#decoding-and-encoding-unions","content":"The SimpleRestJson protocol supports 3 different union encodings : tagged (default)untaggeddiscriminated See the section about unions for a detailed description. ","version":"Next","tagName":"h2"},{"title":"Json Array Arity​","type":1,"pageTitle":"The SimpleRestJson protocol","url":"/smithy4s/docs/protocols/simple-rest-json/overview#json-array-arity","content":"By default there is a limit on the arity of an array, which is 1024. This is to prevent the server from being overloaded with a large array as this is a vector for attacks.This limit can be changed by setting the maxArity smithy4s.http4s.SimpleRestJsonBuilder.withMaxArity(.) to the desired value.an example can be seen in the client example ","version":"Next","tagName":"h2"},{"title":"Explicit Null Encoding​","type":1,"pageTitle":"The SimpleRestJson protocol","url":"/smithy4s/docs/protocols/simple-rest-json/overview#explicit-null-encoding","content":"By default, optional properties (headers, query parameters, structure fields) that are set to None and optional properties that are set to default value will be excluded during encoding process. If you wish to change this so that instead they are included and set to null explicitly, you can do so by calling .withExplicitDefaultsEncoding(true). ","version":"Next","tagName":"h2"},{"title":"Supported traits​","type":1,"pageTitle":"The SimpleRestJson protocol","url":"/smithy4s/docs/protocols/simple-rest-json/overview#supported-traits-1","content":"Here is the list of traits supported by SimpleRestJson smithy.api#defaultsmithy.api#errorsmithy.api#httpsmithy.api#httpErrorsmithy.api#httpHeadersmithy.api#httpLabelsmithy.api#httpPayloadsmithy.api#httpPrefixHeaderssmithy.api#httpQuerysmithy.api#httpQueryParamssmithy.api#httpResponseCodesmithy.api#jsonNamesmithy.api#lengthsmithy.api#patternsmithy.api#rangesmithy.api#requiredsmithy.api#timestampFormatalloy#uuidFormatalloy#discriminatedalloy#nullablealloy#untagged Currently, @cors is not supported. This is because the @cors annotation is too restrictive. You can still use it in your model and configure your API using the information found in the generated code. See the Cors.scala file in the guides module for an example. ","version":"Next","tagName":"h2"},{"title":"Structured Strings​","type":1,"pageTitle":"The SimpleRestJson protocol","url":"/smithy4s/docs/protocols/simple-rest-json/overview#structured-strings","content":"As of smithy4s version 0.18.x, you are able to create strings which are parsed directly into structures for you. This can be accomplished using the alloy#structurePattern trait. For example: @structurePattern(pattern: &quot;{foo}_{bar}&quot;, target: FooBar) string FooBarString structure FooBar { @required foo: String @required bar: Integer }  Now wherever FooBarString is used, it will really be parsing the string into the structure FooBar. As such, the generated code will replace instances of FooBarString with FooBar such that the parsing logic is abstracted away from your implementation. See the alloy documentation for more information. ","version":"Next","tagName":"h2"},{"title":"SimpleRestJson client","type":0,"sectionRef":"#","url":"/smithy4s/docs/protocols/simple-rest-json/client","content":"","keywords":"","version":"Next"},{"title":"Error Handling​","type":1,"pageTitle":"SimpleRestJson client","url":"/smithy4s/docs/protocols/simple-rest-json/client#error-handling","content":"Smithy4s clients map HTTP error responses to the errors defined in the underlying smithy model in the following ways: X-Error-Type​ If an X-Error-Type header is present on the response from the server, the value of this header is used to map the response to a specific error type. The header's value can be either the ShapeId of the error it is targeting OR the name without the namespace. The value of this header is case sensitive. Here are some examples of an X-Error-Type header: X-Error-Type: NotFoundError AND X-Error-Type: example.test#NotFoundError could each be used to map to the error type NotFoundError. This of course assumes that the NotFoundError is provided in either the service or operation errors array provided in the smithy model. All smithy4s services provide an X-Error-Type in responses by default. Status Code​ If the X-Error-Type header is not defined, smithy4s clients will use the status code to attempt to decide which error type to utilize. It does so as follows: If there is a single Error type that contains the correct status code in the httpError trait, this type will be used. If there are two error types with the same status code, an UnknownErrorResponse will be surfaced to the client.If there is NOT a matching status code, but there is a single error marked with the error trait, this error type will be used as long as the returned status code is in the range for either a client or server error. In other words if a single error shape has no status code, but is annotated with @error(&quot;client&quot;) and the returned status code is 404 then this error type will be used. If there are multiple error types with no status code and a matching error type (client/server), then an UnknownErrorResponse will be surfaced to the client. Here are some examples to show more what this looks like. Example smithy model: operation TestOp { ... errors: [NotFoundError, ServiceUnavailableError, CatchAllClientError, CatchAllServerError] } @httpError(404) @error(&quot;client&quot;) structure NotFoundError { message: String } @httpError(503) @error(&quot;server&quot;) structure ServiceUnavailableError { message: String } @error(&quot;client&quot;) structure CatchAllClientError { message String } @error(&quot;server&quot;) structure CatchAllServerError { message String }  And here are some scenarios using this example model. For all of these, assume that NO X-Error-Type header is provided. Status Code\tError Selected404\tNotFoundError 400\tCatchAllClientError 503\tServiceUnavailableError 500\tCatchAllServerError However, adding another error to the operation that looks like: @error(&quot;client&quot;) structure AnotherError { message: String }  Would result in the following: Status Code\tError Selected404\tNotFoundError 400\tUnknownErrorResponse 503\tServiceUnavailableError 500\tCatchAllServerError Notice that the 400 status code cannot be properly mapped. This is because there is no exact match AND there are two errors that are labeled with @error(&quot;client&quot;) which also do not have an associated httpError trait containing a status code. Adding another error type to the operation that looks like: @httpError(404) @error(&quot;client&quot;) structure AnotherNotFoundError { message: String }  Will result in the following: Status Code\tError Selected404\tUnknownErrorResponse 400\tUnknownErrorResponse 503\tServiceUnavailableError 500\tCatchAllServerError Now the 404 status code cannot be mapped. This is due to the fact that two different error types are annotated with a 404 httpError trait. This means that the smithy4s client is not able to decide which of these errors is correct. ","version":"Next","tagName":"h2"},{"title":"Openapi","type":0,"sectionRef":"#","url":"/smithy4s/docs/protocols/simple-rest-json/openapi","content":"","keywords":"","version":"Next"},{"title":"Swagger UI​","type":1,"pageTitle":"Openapi","url":"/smithy4s/docs/protocols/simple-rest-json/openapi#swagger-ui","content":"When you visit your documentation page, you'll be served with a Swagger UI application that looks like this:  If your documentation route supports multiple service, the dropdown in the top bar (top right) should allow you to select other specifications:  ","version":"Next","tagName":"h2"},{"title":"Editor Support","type":0,"sectionRef":"#","url":"/smithy4s/docs/the-smithy-idl/editor-support","content":"","keywords":"","version":"Next"},{"title":"Configuration​","type":1,"pageTitle":"Editor Support","url":"/smithy4s/docs/the-smithy-idl/editor-support#configuration","content":"You can configure your language server using a smithy-build.json at the root of the workspace. The smithy4s plugins have a task to generate that file according to your modules configuration. For sbt: sbt smithy4sUpdateLSPConfig and mill: mill smithy4s.codegen.LSP/updateConfig. If you already have a file, it will merge the existing file with the generated configuration. ","version":"Next","tagName":"h2"},{"title":"The Smithy IDL","type":0,"sectionRef":"#","url":"/smithy4s/docs/the-smithy-idl/smithy-idl","content":"","keywords":"","version":"Next"},{"title":"The smithy metamodel​","type":1,"pageTitle":"The Smithy IDL","url":"/smithy4s/docs/the-smithy-idl/smithy-idl#the-smithy-metamodel","content":"In this section, we'll list various available shapes that let you define data and operations in smithy, and how they translate in the Scala code generated by Smithy4s. ","version":"Next","tagName":"h2"},{"title":"Primitive types​","type":1,"pageTitle":"The Smithy IDL","url":"/smithy4s/docs/the-smithy-idl/smithy-idl#primitive-types","content":"Smithy provides the following &quot;primitive&quot; types out of the box. BooleanStringIntegerLongFloatShortDoubleByteBigIntegerBigDecimalBlob (smithy4s.Blob, wrapper to Array[Byte] or ByteBuffer)Timestamp (smithy4s.Timestamp, translated from/to java or javascript time types)Document (smithy4s.Document, a bespoke Json ADT) ","version":"Next","tagName":"h3"},{"title":"Named primitives​","type":1,"pageTitle":"The Smithy IDL","url":"/smithy4s/docs/the-smithy-idl/smithy-idl#named-primitives","content":"Smithy lets you define custom names for primitive types: namespace foo integer Age long Identifier  These get translated as unboxed type wrappers, or newtypes, that look like a case class but do not induce any boxing at runtime. ","version":"Next","tagName":"h3"},{"title":"Collection types​","type":1,"pageTitle":"The Smithy IDL","url":"/smithy4s/docs/the-smithy-idl/smithy-idl#collection-types","content":"Smithy provides 3 different shapes of collections: lists, sets, and maps. They translate to the corresponding scala.collection types in the generated Scala code. namespace foo list IntList { member: Integer } set StringSet { member: String } // At this time, only string shapes can be used as keys to map. map AgeMap { key: String value: Integer }  ","version":"Next","tagName":"h3"},{"title":"Enums​","type":1,"pageTitle":"The Smithy IDL","url":"/smithy4s/docs/the-smithy-idl/smithy-idl#enums","content":"Smithy supports two types of enums, for string and integers : enum FooBar { FOO = &quot;foo&quot; BAR = &quot;bar&quot; } intEnum FaceCard { JACK = 1 QUEEN = 2 KING = 3 ACE = 4 JOKER = 5 }  ","version":"Next","tagName":"h3"},{"title":"Structures​","type":1,"pageTitle":"The Smithy IDL","url":"/smithy4s/docs/the-smithy-idl/smithy-idl#structures","content":"Structures are product types. In Scala, they naturally translate to case classes. namespace foo structure Person { @required firstName: String @required lastName: String dateOfBirth: Timestamp }  ","version":"Next","tagName":"h3"},{"title":"Unions​","type":1,"pageTitle":"The Smithy IDL","url":"/smithy4s/docs/the-smithy-idl/smithy-idl#unions","content":"Unions are coproduct types. In Scala, they quite naturally translate to sealed traits. Union members can target any data shape, be it a structure or a primitive type. namespace foo structure Cat { name: String } structure Dog { name: String } union Animal { cat: Cat dog: Dog }  ","version":"Next","tagName":"h3"},{"title":"Operations and services​","type":1,"pageTitle":"The Smithy IDL","url":"/smithy4s/docs/the-smithy-idl/smithy-idl#operations-and-services","content":"Operations​ Operations are essentially an optional Input, an optional Output, and an optional list of errors. Inputs, outputs and errors all have to be structure shapes. namespace foo operation Greet { input: GreetInput output: GreetOutput errors: [BadInput] } structure GreetInput { name: String } structure GreetOutput { message: String } @error(&quot;client&quot;) structure BadInput { message: String }  Errors​ Regarding errors, smithy4s translates them as case classes extending Throwable. The getMessage method of the throwable is implemented in terms of the following (based on the first match): a field annotated with the @errorMessage traita field named message Services​ Services are basically a list of operations, and an optional list of errors. namespace foo service HelloService { operations: [Greet] errors: [ServerError] } @error(&quot;server&quot;) structure ServerError { message: String }  Smithy4s translates them in the following fashion: package object foo { type HelloService[F[_]] = HelloServiceGen[???] }  HelloService is type alias that exposes a normal &quot;functor-shaped&quot; type parameter: we are aware that the most common usecase of Smithy4s abides by the &quot;capatibility trait&quot; pattern (or tagless-final), against effect types that probably abide by the cats-effect semantics. However, the actual interface is HelloServiceGen, which has a higher degree of polymorphism. It looks like this: package foo trait HelloServiceGen[P[_, _, _, _, _]]{ def greet(name: String): P[GreetInput, Greet.Error, GreetOutput, Nothing, Nothing] }  P represents an abstract context against which operations are going to run. The abstract context has 5 type parameters: inputerroroutputstreamed input (Nothing, most of the time)streamed output (Nothing, most of the time) Keeping track of these parameters is really important for the implementation intepreters. It also opens the door for providing interpreters that work against bi-functors (EitherT[IO, *, *]) without changing the generated code. ","version":"Next","tagName":"h3"},{"title":"Currently not supported (in particular)​","type":1,"pageTitle":"The Smithy IDL","url":"/smithy4s/docs/the-smithy-idl/smithy-idl#currently-not-supported-in-particular","content":"Smithy has a resource type of shape, that represents CRUD specialized services. Smithy4s only transitively transfers the operations defined in a resource to the service that lists that resource. ","version":"Next","tagName":"h3"},{"title":"SimpleRestJson server","type":0,"sectionRef":"#","url":"/smithy4s/docs/protocols/simple-rest-json/server","content":"","keywords":"","version":"Next"},{"title":"A note about errors​","type":1,"pageTitle":"SimpleRestJson server","url":"/smithy4s/docs/protocols/simple-rest-json/server#a-note-about-errors","content":"When encountering data types annotated with the @error trait in smithy, smithy4s will ensure that the generated types extend Throwable. The interpreters are aware of it, and try to recover any error raised in your effect-types that your smithy specs know about, in order to render it correctly in Json and apply the specified status code (see the @httpError trait for this). As a convenience, Smithy4s provides mapErrors and flatMapErrors methods, that allow to intercept exceptions that were not specified in the spec, and transform them into exceptions that were. In particular, the smithy4s interpreters raise specific errors when they fail to decode http requests. The mapErrors and flatMapErrors methods can be used to ensure that a specified error is returned by your service: myRoutes.mapErrors{ case e: PayloadError =&gt; MyClientError(...) }.resource  ","version":"Next","tagName":"h2"},{"title":"Wiring the routes​","type":1,"pageTitle":"SimpleRestJson server","url":"/smithy4s/docs/protocols/simple-rest-json/server#wiring-the-routes","content":"As a reminder, to wire those routes into a server, you need something like: import cats.effect._ import org.http4s.ember.server._ import org.http4s.implicits._ import com.comcast.ip4s._ object Main extends IOApp { def run(args: List[String]): IO[ExitCode] = Routes.myRoutes.flatMap { routes =&gt; EmberServerBuilder.default[IO] .withPort(port&quot;9000&quot;) .withHost(host&quot;localhost&quot;) .withHttpApp(routes.orNotFound) .build }.use(_ =&gt; IO.never) .as(ExitCode.Success) }  ","version":"Next","tagName":"h2"},{"title":"Smithy traits","type":0,"sectionRef":"#","url":"/smithy4s/docs/the-smithy-idl/traits","content":"","keywords":"","version":"Next"},{"title":"Creating your own traits​","type":1,"pageTitle":"Smithy traits","url":"/smithy4s/docs/the-smithy-idl/traits#creating-your-own-traits","content":"Smithy makes it really easy to create your own traits: namespace foo @trait(selector: &quot;:is(structure)&quot;) string customThing @customThing(&quot;hello&quot;) structure MyStructure { }  ","version":"Next","tagName":"h3"},{"title":"Regarding Smithy4s handling of traits​","type":1,"pageTitle":"Smithy traits","url":"/smithy4s/docs/the-smithy-idl/traits#regarding-smithy4s-handling-of-traits","content":"Smithy4s automatically creates corresponding values in the generated Scala code, for all the annotations it finds, whether defined in the smithy prelude, or defined by users. These values can be retrieved via some interfaces that will be documented in a near future. ","version":"Next","tagName":"h3"},{"title":"AWS","type":0,"sectionRef":"#","url":"/smithy4s/docs/protocols/aws/aws","content":"","keywords":"","version":"Next"},{"title":"What is missing ?​","type":1,"pageTitle":"AWS","url":"/smithy4s/docs/protocols/aws/aws#what-is-missing-","content":"streaming operations (such as S3 putObject, getObject, or Kinesis' subscribeToShard) are currently unsupported.service-specific customisations are currently unsupported.users should not use smithy4s to get data into/out of AWS S3 ","version":"Next","tagName":"h3"},{"title":"Note on pre-built artifacts​","type":1,"pageTitle":"AWS","url":"/smithy4s/docs/protocols/aws/aws#note-on-pre-built-artifacts","content":"We (the Smithy4s maintainers) do not intend to publish pre-generated artifacts containing the AWS clients, there's a lot of nuance there and maintainance burden that we do not have the capacity to assume. In particular, backward binary compatibility of the generated code is impossible to guarantee at this time. ","version":"Next","tagName":"h3"},{"title":"Setup​","type":1,"pageTitle":"AWS","url":"/smithy4s/docs/protocols/aws/aws#setup","content":"","version":"Next","tagName":"h2"},{"title":"SBT​","type":1,"pageTitle":"AWS","url":"/smithy4s/docs/protocols/aws/aws#sbt","content":"In build.sbt libraryDependencies ++= Seq( &quot;com.disneystreaming.smithy4s&quot; %% &quot;smithy4s-aws-http4s&quot; % smithy4sVersion.value ) // The `AWS` object contains a list of references to artifacts that contain specifications to AWS services. smithy4sAwsSpecs ++= Seq(AWS.dynamodb)  Alternatively, the following is also valid : libraryDependencies ++= Seq( // version sourced from the plugin &quot;com.disneystreaming.smithy4s&quot; %% &quot;smithy4s-aws-http4s&quot; % smithy4sVersion.value &quot;com.disneystreaming.smithy&quot; % &quot;aws-dynamodb-spec&quot; % &quot;2023.09.22&quot; % Smithy4s )  ","version":"Next","tagName":"h3"},{"title":"Mill​","type":1,"pageTitle":"AWS","url":"/smithy4s/docs/protocols/aws/aws#mill","content":"In build.sc import $ivy.`com.disneystreaming.smithy4s::smithy4s-mill-codegen-plugin::0.18.16` import smithy4s.codegen.mill._ object foo extends Smithy4sModule { override def scalaVersion = &quot;2.13.10&quot; override def ivyDeps = Agg( ivy&quot;com.disneystreaming.smithy4s::smithy4s-aws-http4s:${smithy4sVersion()}&quot;, ) override def smithy4sAwsSpecs: T[Seq[String]] = T(Seq(AWS.dynamodb)) }  ","version":"Next","tagName":"h3"},{"title":"Example usage​","type":1,"pageTitle":"AWS","url":"/smithy4s/docs/protocols/aws/aws#example-usage","content":"In your Scala code: import cats.effect._ import org.http4s.ember.client.EmberClientBuilder import smithy4s.aws._ // AWS specific interpreters // AWS specific interpreters import com.amazonaws.dynamodb._ // Generated code from specs. // Generated code from specs. object Main extends IOApp.Simple { def run = resource.use { case (dynamodb) =&gt; dynamodb .listTables(limit = Some(ListTablesInputLimit(10))) .flatMap(IO.println(_)) } val resource: Resource[IO, DynamoDB[IO]] = for { httpClient &lt;- EmberClientBuilder.default[IO].build awsEnv &lt;- AwsEnvironment.default(httpClient, AwsRegion.US_EAST_1) dynamodb &lt;- AwsClient(DynamoDB, awsEnv) } yield dynamodb }  ","version":"Next","tagName":"h2"},{"title":"Note on where to find the AWS specifications​","type":1,"pageTitle":"AWS","url":"/smithy4s/docs/protocols/aws/aws#note-on-where-to-find-the-aws-specifications","content":"SBT : &quot;com.disneystreaming.smithy&quot; % s&quot;aws-${service_name}-spec&quot; % &quot;2023.09.22&quot;Mill : ivy&quot;com.disneystreaming.smithy:aws-${service_name}-spec:2023.09.22&quot; The version corresponds to the latest release in this repo: aws-sdk-smithy-specs. AWS does not publishes the specs to their services to Maven. However, The specs in question (that are written in json syntax) can be found in some of the official SDKs published by AWS. These .json files can be understood by smithy4s, just like .smithy, and can be used to generate code. The aws-sdk-smithy-specs project periodically gathers the specs from the Javascript SDK repo and publishes them to maven central to lower the barrier of entry. ","version":"Next","tagName":"h2"},{"title":"Service summary​","type":1,"pageTitle":"AWS","url":"/smithy4s/docs/protocols/aws/aws#service-summary","content":"Below you'll find a generated summary of the maven coordinates for the AWS specifications. Note that the version of the spec might not be the latest one. Refer yourself to this repo to get the latest version of the specs. ","version":"Next","tagName":"h2"},{"title":"✅ Supported (at least partially)​","type":1,"pageTitle":"AWS","url":"/smithy4s/docs/protocols/aws/aws#-supported-at-least-partially","content":"","version":"Next","tagName":"h3"},{"title":"restJson1​","type":1,"pageTitle":"AWS","url":"/smithy4s/docs/protocols/aws/aws#restjson1","content":"✅ accessanalyzer​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-accessanalyzer-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-accessanalyzer-spec:2023.09.22&quot; ✅ account​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-account-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-account-spec:2023.09.22&quot; ✅ amp​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-amp-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-amp-spec:2023.09.22&quot; ✅ amplify​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-amplify-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-amplify-spec:2023.09.22&quot; ✅ amplifybackend​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-amplifybackend-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-amplifybackend-spec:2023.09.22&quot; ✅ amplifyuibuilder​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-amplifyuibuilder-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-amplifyuibuilder-spec:2023.09.22&quot; ✅ api-gateway​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-api-gateway-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-api-gateway-spec:2023.09.22&quot; ✅ apigatewaymanagementapi​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-apigatewaymanagementapi-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-apigatewaymanagementapi-spec:2023.09.22&quot; ✅ apigatewayv2​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-apigatewayv2-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-apigatewayv2-spec:2023.09.22&quot; ✅ app-mesh​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-app-mesh-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-app-mesh-spec:2023.09.22&quot; ✅ appconfig​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-appconfig-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-appconfig-spec:2023.09.22&quot; ✅ appconfigdata​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-appconfigdata-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-appconfigdata-spec:2023.09.22&quot; ✅ appfabric​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-appfabric-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-appfabric-spec:2023.09.22&quot; ✅ appflow​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-appflow-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-appflow-spec:2023.09.22&quot; ✅ appintegrations​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-appintegrations-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-appintegrations-spec:2023.09.22&quot; ✅ applicationcostprofiler​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-applicationcostprofiler-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-applicationcostprofiler-spec:2023.09.22&quot; ✅ appsync​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-appsync-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-appsync-spec:2023.09.22&quot; ✅ arc-zonal-shift​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-arc-zonal-shift-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-arc-zonal-shift-spec:2023.09.22&quot; ✅ auditmanager​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-auditmanager-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-auditmanager-spec:2023.09.22&quot; ✅ backup​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-backup-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-backup-spec:2023.09.22&quot; ⚠️ backupstorage​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-backupstorage-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-backupstorage-spec:2023.09.22&quot; Unsupported streaming operations NotifyObjectCompletePutChunkPutObjectGetChunkGetObjectMetadata ✅ batch​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-batch-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-batch-spec:2023.09.22&quot; ✅ billingconductor​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-billingconductor-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-billingconductor-spec:2023.09.22&quot; ✅ braket​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-braket-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-braket-spec:2023.09.22&quot; ✅ chime-sdk-identity​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-chime-sdk-identity-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-chime-sdk-identity-spec:2023.09.22&quot; ✅ chime-sdk-media-pipelines​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-chime-sdk-media-pipelines-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-chime-sdk-media-pipelines-spec:2023.09.22&quot; ✅ chime-sdk-meetings​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-chime-sdk-meetings-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-chime-sdk-meetings-spec:2023.09.22&quot; ✅ chime-sdk-messaging​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-chime-sdk-messaging-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-chime-sdk-messaging-spec:2023.09.22&quot; ✅ chime-sdk-voice​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-chime-sdk-voice-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-chime-sdk-voice-spec:2023.09.22&quot; ✅ chime​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-chime-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-chime-spec:2023.09.22&quot; ✅ cleanrooms​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-cleanrooms-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-cleanrooms-spec:2023.09.22&quot; ✅ clouddirectory​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-clouddirectory-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-clouddirectory-spec:2023.09.22&quot; ⚠️ cloudsearch-domain​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-cloudsearch-domain-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-cloudsearch-domain-spec:2023.09.22&quot; Unsupported streaming operations UploadDocuments ✅ cloudtrail-data​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-cloudtrail-data-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-cloudtrail-data-spec:2023.09.22&quot; ⚠️ codeartifact​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-codeartifact-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-codeartifact-spec:2023.09.22&quot; Unsupported streaming operations GetPackageVersionAssetPublishPackageVersion ✅ codecatalyst​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-codecatalyst-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-codecatalyst-spec:2023.09.22&quot; ✅ codeguru-reviewer​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-codeguru-reviewer-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-codeguru-reviewer-spec:2023.09.22&quot; ✅ codeguru-security​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-codeguru-security-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-codeguru-security-spec:2023.09.22&quot; ✅ codeguruprofiler​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-codeguruprofiler-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-codeguruprofiler-spec:2023.09.22&quot; ✅ codestar-notifications​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-codestar-notifications-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-codestar-notifications-spec:2023.09.22&quot; ✅ cognito-sync​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-cognito-sync-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-cognito-sync-spec:2023.09.22&quot; ✅ connect-contact-lens​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-connect-contact-lens-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-connect-contact-lens-spec:2023.09.22&quot; ✅ connect​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-connect-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-connect-spec:2023.09.22&quot; ✅ connectcampaigns​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-connectcampaigns-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-connectcampaigns-spec:2023.09.22&quot; ✅ connectcases​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-connectcases-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-connectcases-spec:2023.09.22&quot; ✅ connectparticipant​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-connectparticipant-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-connectparticipant-spec:2023.09.22&quot; ✅ controltower​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-controltower-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-controltower-spec:2023.09.22&quot; ✅ customer-profiles​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-customer-profiles-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-customer-profiles-spec:2023.09.22&quot; ✅ databrew​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-databrew-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-databrew-spec:2023.09.22&quot; ✅ dataexchange​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-dataexchange-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-dataexchange-spec:2023.09.22&quot; ✅ detective​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-detective-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-detective-spec:2023.09.22&quot; ✅ devops-guru​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-devops-guru-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-devops-guru-spec:2023.09.22&quot; ✅ dlm​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-dlm-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-dlm-spec:2023.09.22&quot; ✅ docdb-elastic​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-docdb-elastic-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-docdb-elastic-spec:2023.09.22&quot; ✅ drs​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-drs-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-drs-spec:2023.09.22&quot; ⚠️ ebs​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-ebs-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-ebs-spec:2023.09.22&quot; Unsupported streaming operations PutSnapshotBlockGetSnapshotBlock ✅ efs​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-efs-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-efs-spec:2023.09.22&quot; ✅ eks​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-eks-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-eks-spec:2023.09.22&quot; ✅ elastic-inference​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-elastic-inference-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-elastic-inference-spec:2023.09.22&quot; ✅ elastic-transcoder​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-elastic-transcoder-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-elastic-transcoder-spec:2023.09.22&quot; ✅ elasticsearch-service​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-elasticsearch-service-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-elasticsearch-service-spec:2023.09.22&quot; ✅ emr-containers​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-emr-containers-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-emr-containers-spec:2023.09.22&quot; ✅ emr-serverless​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-emr-serverless-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-emr-serverless-spec:2023.09.22&quot; ✅ entityresolution​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-entityresolution-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-entityresolution-spec:2023.09.22&quot; ✅ evidently​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-evidently-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-evidently-spec:2023.09.22&quot; ✅ finspace-data​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-finspace-data-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-finspace-data-spec:2023.09.22&quot; ✅ finspace​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-finspace-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-finspace-spec:2023.09.22&quot; ✅ fis​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-fis-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-fis-spec:2023.09.22&quot; ✅ gamesparks​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-gamesparks-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-gamesparks-spec:2023.09.22&quot; ⚠️ glacier​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-glacier-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-glacier-spec:2023.09.22&quot; Unsupported streaming operations GetJobOutputUploadArchiveUploadMultipartPart ✅ grafana​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-grafana-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-grafana-spec:2023.09.22&quot; ✅ greengrass​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-greengrass-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-greengrass-spec:2023.09.22&quot; ✅ greengrassv2​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-greengrassv2-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-greengrassv2-spec:2023.09.22&quot; ✅ groundstation​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-groundstation-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-groundstation-spec:2023.09.22&quot; ✅ guardduty​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-guardduty-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-guardduty-spec:2023.09.22&quot; ✅ honeycode​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-honeycode-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-honeycode-spec:2023.09.22&quot; ✅ imagebuilder​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-imagebuilder-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-imagebuilder-spec:2023.09.22&quot; ✅ inspector2​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-inspector2-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-inspector2-spec:2023.09.22&quot; ✅ internetmonitor​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-internetmonitor-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-internetmonitor-spec:2023.09.22&quot; ✅ iot-1click-devices-service​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-iot-1click-devices-service-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-iot-1click-devices-service-spec:2023.09.22&quot; ✅ iot-1click-projects​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-iot-1click-projects-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-iot-1click-projects-spec:2023.09.22&quot; ✅ iot-data-plane​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-iot-data-plane-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-iot-data-plane-spec:2023.09.22&quot; ✅ iot-events-data​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-iot-events-data-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-iot-events-data-spec:2023.09.22&quot; ✅ iot-events​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-iot-events-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-iot-events-spec:2023.09.22&quot; ✅ iot-jobs-data-plane​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-iot-jobs-data-plane-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-iot-jobs-data-plane-spec:2023.09.22&quot; ✅ iot-roborunner​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-iot-roborunner-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-iot-roborunner-spec:2023.09.22&quot; ✅ iot-wireless​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-iot-wireless-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-iot-wireless-spec:2023.09.22&quot; ✅ iot​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-iot-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-iot-spec:2023.09.22&quot; ✅ iotanalytics​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-iotanalytics-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-iotanalytics-spec:2023.09.22&quot; ✅ iotdeviceadvisor​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-iotdeviceadvisor-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-iotdeviceadvisor-spec:2023.09.22&quot; ✅ iotfleethub​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-iotfleethub-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-iotfleethub-spec:2023.09.22&quot; ✅ iotsitewise​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-iotsitewise-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-iotsitewise-spec:2023.09.22&quot; ✅ iottwinmaker​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-iottwinmaker-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-iottwinmaker-spec:2023.09.22&quot; ✅ ivs-realtime​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-ivs-realtime-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-ivs-realtime-spec:2023.09.22&quot; ✅ ivs​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-ivs-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-ivs-spec:2023.09.22&quot; ✅ ivschat​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-ivschat-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-ivschat-spec:2023.09.22&quot; ✅ kafka​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-kafka-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-kafka-spec:2023.09.22&quot; ✅ kafkaconnect​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-kafkaconnect-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-kafkaconnect-spec:2023.09.22&quot; ⚠️ kinesis-video-archived-media​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-kinesis-video-archived-media-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-kinesis-video-archived-media-spec:2023.09.22&quot; Unsupported streaming operations GetClipGetMediaForFragmentList ⚠️ kinesis-video-media​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-kinesis-video-media-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-kinesis-video-media-spec:2023.09.22&quot; Unsupported streaming operations GetMedia ✅ kinesis-video-signaling​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-kinesis-video-signaling-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-kinesis-video-signaling-spec:2023.09.22&quot; ✅ kinesis-video-webrtc-storage​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-kinesis-video-webrtc-storage-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-kinesis-video-webrtc-storage-spec:2023.09.22&quot; ✅ kinesis-video​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-kinesis-video-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-kinesis-video-spec:2023.09.22&quot; ⚠️ lakeformation​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-lakeformation-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-lakeformation-spec:2023.09.22&quot; Unsupported streaming operations GetWorkUnitResults ⚠️ lambda​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-lambda-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-lambda-spec:2023.09.22&quot; Unsupported streaming operations InvokeWithResponseStreamInvokeAsync ✅ lex-model-building-service​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-lex-model-building-service-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-lex-model-building-service-spec:2023.09.22&quot; ✅ lex-models-v2​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-lex-models-v2-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-lex-models-v2-spec:2023.09.22&quot; ⚠️ lex-runtime-service​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-lex-runtime-service-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-lex-runtime-service-spec:2023.09.22&quot; Unsupported streaming operations PostContentPutSession ⚠️ lex-runtime-v2​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-lex-runtime-v2-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-lex-runtime-v2-spec:2023.09.22&quot; Unsupported streaming operations RecognizeUtterancePutSessionStartConversation ✅ license-manager-linux-subscriptions​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-license-manager-linux-subscriptions-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-license-manager-linux-subscriptions-spec:2023.09.22&quot; ✅ license-manager-user-subscriptions​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-license-manager-user-subscriptions-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-license-manager-user-subscriptions-spec:2023.09.22&quot; ✅ location​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-location-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-location-spec:2023.09.22&quot; ✅ lookoutmetrics​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-lookoutmetrics-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-lookoutmetrics-spec:2023.09.22&quot; ⚠️ lookoutvision​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-lookoutvision-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-lookoutvision-spec:2023.09.22&quot; Unsupported streaming operations DetectAnomalies ✅ m2​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-m2-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-m2-spec:2023.09.22&quot; ✅ macie2​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-macie2-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-macie2-spec:2023.09.22&quot; ✅ managedblockchain-query​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-managedblockchain-query-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-managedblockchain-query-spec:2023.09.22&quot; ✅ managedblockchain​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-managedblockchain-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-managedblockchain-spec:2023.09.22&quot; ✅ marketplace-catalog​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-marketplace-catalog-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-marketplace-catalog-spec:2023.09.22&quot; ✅ mediaconnect​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-mediaconnect-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-mediaconnect-spec:2023.09.22&quot; ✅ mediaconvert​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-mediaconvert-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-mediaconvert-spec:2023.09.22&quot; ⚠️ medialive​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-medialive-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-medialive-spec:2023.09.22&quot; Unsupported streaming operations DescribeInputDeviceThumbnail ✅ mediapackage-vod​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-mediapackage-vod-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-mediapackage-vod-spec:2023.09.22&quot; ✅ mediapackage​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-mediapackage-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-mediapackage-spec:2023.09.22&quot; ✅ mediapackagev2​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-mediapackagev2-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-mediapackagev2-spec:2023.09.22&quot; ⚠️ mediastore-data​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-mediastore-data-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-mediastore-data-spec:2023.09.22&quot; Unsupported streaming operations PutObjectGetObject ✅ mediatailor​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-mediatailor-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-mediatailor-spec:2023.09.22&quot; ⚠️ medical-imaging​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-medical-imaging-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-medical-imaging-spec:2023.09.22&quot; Unsupported streaming operations GetImageSetMetadataGetImageFrame ✅ mgn​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-mgn-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-mgn-spec:2023.09.22&quot; ✅ migration-hub-refactor-spaces​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-migration-hub-refactor-spaces-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-migration-hub-refactor-spaces-spec:2023.09.22&quot; ✅ migrationhuborchestrator​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-migrationhuborchestrator-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-migrationhuborchestrator-spec:2023.09.22&quot; ✅ migrationhubstrategy​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-migrationhubstrategy-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-migrationhubstrategy-spec:2023.09.22&quot; ✅ mobile​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-mobile-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-mobile-spec:2023.09.22&quot; ✅ mq​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-mq-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-mq-spec:2023.09.22&quot; ✅ mwaa​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-mwaa-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-mwaa-spec:2023.09.22&quot; ✅ neptunedata​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-neptunedata-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-neptunedata-spec:2023.09.22&quot; ✅ networkmanager​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-networkmanager-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-networkmanager-spec:2023.09.22&quot; ✅ nimble​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-nimble-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-nimble-spec:2023.09.22&quot; ✅ oam​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-oam-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-oam-spec:2023.09.22&quot; ⚠️ omics​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-omics-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-omics-spec:2023.09.22&quot; Unsupported streaming operations GetReferenceGetReadSetUploadReadSetPart ✅ opensearch​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-opensearch-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-opensearch-spec:2023.09.22&quot; ✅ osis​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-osis-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-osis-spec:2023.09.22&quot; ✅ outposts​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-outposts-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-outposts-spec:2023.09.22&quot; ✅ panorama​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-panorama-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-panorama-spec:2023.09.22&quot; ✅ payment-cryptography-data​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-payment-cryptography-data-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-payment-cryptography-data-spec:2023.09.22&quot; ✅ pca-connector-ad​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-pca-connector-ad-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-pca-connector-ad-spec:2023.09.22&quot; ✅ personalize-events​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-personalize-events-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-personalize-events-spec:2023.09.22&quot; ✅ personalize-runtime​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-personalize-runtime-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-personalize-runtime-spec:2023.09.22&quot; ✅ pinpoint-email​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-pinpoint-email-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-pinpoint-email-spec:2023.09.22&quot; ✅ pinpoint-sms-voice​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-pinpoint-sms-voice-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-pinpoint-sms-voice-spec:2023.09.22&quot; ✅ pinpoint​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-pinpoint-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-pinpoint-spec:2023.09.22&quot; ✅ pipes​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-pipes-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-pipes-spec:2023.09.22&quot; ⚠️ polly​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-polly-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-polly-spec:2023.09.22&quot; Unsupported streaming operations SynthesizeSpeech ✅ privatenetworks​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-privatenetworks-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-privatenetworks-spec:2023.09.22&quot; ✅ qldb​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-qldb-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-qldb-spec:2023.09.22&quot; ✅ quicksight​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-quicksight-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-quicksight-spec:2023.09.22&quot; ✅ ram​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-ram-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-ram-spec:2023.09.22&quot; ✅ rbin​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-rbin-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-rbin-spec:2023.09.22&quot; ✅ rds-data​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-rds-data-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-rds-data-spec:2023.09.22&quot; ⚠️ rekognitionstreaming​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-rekognitionstreaming-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-rekognitionstreaming-spec:2023.09.22&quot; Unsupported streaming operations StartFaceLivenessSession ✅ resiliencehub​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-resiliencehub-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-resiliencehub-spec:2023.09.22&quot; ✅ resource-explorer-2​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-resource-explorer-2-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-resource-explorer-2-spec:2023.09.22&quot; ✅ resource-groups​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-resource-groups-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-resource-groups-spec:2023.09.22&quot; ✅ robomaker​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-robomaker-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-robomaker-spec:2023.09.22&quot; ✅ rolesanywhere​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-rolesanywhere-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-rolesanywhere-spec:2023.09.22&quot; ✅ route53-recovery-control-config​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-route53-recovery-control-config-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-route53-recovery-control-config-spec:2023.09.22&quot; ✅ route53-recovery-readiness​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-route53-recovery-readiness-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-route53-recovery-readiness-spec:2023.09.22&quot; ✅ rum​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-rum-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-rum-spec:2023.09.22&quot; ✅ s3outposts​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-s3outposts-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-s3outposts-spec:2023.09.22&quot; ✅ sagemaker-a2i-runtime​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-sagemaker-a2i-runtime-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-sagemaker-a2i-runtime-spec:2023.09.22&quot; ✅ sagemaker-edge​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-sagemaker-edge-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-sagemaker-edge-spec:2023.09.22&quot; ✅ sagemaker-featurestore-runtime​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-sagemaker-featurestore-runtime-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-sagemaker-featurestore-runtime-spec:2023.09.22&quot; ⚠️ sagemaker-geospatial​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-sagemaker-geospatial-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-sagemaker-geospatial-spec:2023.09.22&quot; Unsupported streaming operations GetTile ✅ sagemaker-metrics​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-sagemaker-metrics-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-sagemaker-metrics-spec:2023.09.22&quot; ⚠️ sagemaker-runtime​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-sagemaker-runtime-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-sagemaker-runtime-spec:2023.09.22&quot; Unsupported streaming operations InvokeEndpointWithResponseStream ✅ savingsplans​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-savingsplans-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-savingsplans-spec:2023.09.22&quot; ✅ scheduler​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-scheduler-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-scheduler-spec:2023.09.22&quot; ✅ schemas​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-schemas-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-schemas-spec:2023.09.22&quot; ✅ securityhub​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-securityhub-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-securityhub-spec:2023.09.22&quot; ✅ securitylake​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-securitylake-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-securitylake-spec:2023.09.22&quot; ✅ serverlessapplicationrepository​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-serverlessapplicationrepository-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-serverlessapplicationrepository-spec:2023.09.22&quot; ✅ service-catalog-appregistry​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-service-catalog-appregistry-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-service-catalog-appregistry-spec:2023.09.22&quot; ✅ sesv2​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-sesv2-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-sesv2-spec:2023.09.22&quot; ✅ signer​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-signer-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-signer-spec:2023.09.22&quot; ✅ simspaceweaver​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-simspaceweaver-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-simspaceweaver-spec:2023.09.22&quot; ✅ snow-device-management​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-snow-device-management-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-snow-device-management-spec:2023.09.22&quot; ✅ ssm-incidents​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-ssm-incidents-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-ssm-incidents-spec:2023.09.22&quot; ✅ ssm-sap​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-ssm-sap-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-ssm-sap-spec:2023.09.22&quot; ✅ sso-oidc​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-sso-oidc-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-sso-oidc-spec:2023.09.22&quot; ✅ sso​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-sso-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-sso-spec:2023.09.22&quot; ✅ support-app​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-support-app-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-support-app-spec:2023.09.22&quot; ✅ synthetics​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-synthetics-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-synthetics-spec:2023.09.22&quot; ✅ tnb​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-tnb-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-tnb-spec:2023.09.22&quot; ⚠️ transcribe-streaming​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-transcribe-streaming-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-transcribe-streaming-spec:2023.09.22&quot; Unsupported streaming operations StartMedicalStreamTranscriptionStartCallAnalyticsStreamTranscriptionStartStreamTranscription ✅ vpc-lattice​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-vpc-lattice-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-vpc-lattice-spec:2023.09.22&quot; ✅ wellarchitected​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-wellarchitected-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-wellarchitected-spec:2023.09.22&quot; ✅ wisdom​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-wisdom-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-wisdom-spec:2023.09.22&quot; ✅ workdocs​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-workdocs-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-workdocs-spec:2023.09.22&quot; ✅ worklink​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-worklink-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-worklink-spec:2023.09.22&quot; ⚠️ workmailmessageflow​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-workmailmessageflow-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-workmailmessageflow-spec:2023.09.22&quot; Unsupported streaming operations GetRawMessageContent ✅ workspaces-web​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-workspaces-web-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-workspaces-web-spec:2023.09.22&quot; ✅ xray​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-xray-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-xray-spec:2023.09.22&quot; ","version":"Next","tagName":"h3"},{"title":"ec2Query​","type":1,"pageTitle":"AWS","url":"/smithy4s/docs/protocols/aws/aws#ec2query","content":"✅ ec2​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-ec2-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-ec2-spec:2023.09.22&quot; ","version":"Next","tagName":"h3"},{"title":"awsQuery​","type":1,"pageTitle":"AWS","url":"/smithy4s/docs/protocols/aws/aws#awsquery","content":"✅ auto-scaling​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-auto-scaling-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-auto-scaling-spec:2023.09.22&quot; ✅ cloudformation​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-cloudformation-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-cloudformation-spec:2023.09.22&quot; ✅ cloudsearch​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-cloudsearch-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-cloudsearch-spec:2023.09.22&quot; ✅ cloudwatch​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-cloudwatch-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-cloudwatch-spec:2023.09.22&quot; ✅ docdb​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-docdb-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-docdb-spec:2023.09.22&quot; ✅ elastic-beanstalk​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-elastic-beanstalk-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-elastic-beanstalk-spec:2023.09.22&quot; ✅ elastic-load-balancing-v2​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-elastic-load-balancing-v2-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-elastic-load-balancing-v2-spec:2023.09.22&quot; ✅ elastic-load-balancing​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-elastic-load-balancing-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-elastic-load-balancing-spec:2023.09.22&quot; ✅ elasticache​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-elasticache-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-elasticache-spec:2023.09.22&quot; ✅ iam​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-iam-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-iam-spec:2023.09.22&quot; ✅ neptune​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-neptune-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-neptune-spec:2023.09.22&quot; ✅ rds​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-rds-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-rds-spec:2023.09.22&quot; ✅ redshift​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-redshift-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-redshift-spec:2023.09.22&quot; ✅ ses​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-ses-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-ses-spec:2023.09.22&quot; ✅ sns​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-sns-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-sns-spec:2023.09.22&quot; ✅ sqs​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-sqs-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-sqs-spec:2023.09.22&quot; ✅ sts​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-sts-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-sts-spec:2023.09.22&quot; ","version":"Next","tagName":"h3"},{"title":"awsJson1_0​","type":1,"pageTitle":"AWS","url":"/smithy4s/docs/protocols/aws/aws#awsjson1_0","content":"✅ apprunner​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-apprunner-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-apprunner-spec:2023.09.22&quot; ✅ backup-gateway​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-backup-gateway-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-backup-gateway-spec:2023.09.22&quot; ✅ cloudcontrol​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-cloudcontrol-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-cloudcontrol-spec:2023.09.22&quot; ✅ codestar-connections​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-codestar-connections-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-codestar-connections-spec:2023.09.22&quot; ✅ compute-optimizer​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-compute-optimizer-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-compute-optimizer-spec:2023.09.22&quot; ✅ dynamodb-streams​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-dynamodb-streams-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-dynamodb-streams-spec:2023.09.22&quot; ✅ dynamodb​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-dynamodb-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-dynamodb-spec:2023.09.22&quot; ✅ healthlake​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-healthlake-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-healthlake-spec:2023.09.22&quot; ✅ iotfleetwise​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-iotfleetwise-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-iotfleetwise-spec:2023.09.22&quot; ✅ kendra-ranking​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-kendra-ranking-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-kendra-ranking-spec:2023.09.22&quot; ✅ keyspaces​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-keyspaces-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-keyspaces-spec:2023.09.22&quot; ✅ lookoutequipment​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-lookoutequipment-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-lookoutequipment-spec:2023.09.22&quot; ✅ network-firewall​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-network-firewall-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-network-firewall-spec:2023.09.22&quot; ✅ opensearchserverless​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-opensearchserverless-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-opensearchserverless-spec:2023.09.22&quot; ✅ payment-cryptography​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-payment-cryptography-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-payment-cryptography-spec:2023.09.22&quot; ✅ pinpoint-sms-voice-v2​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-pinpoint-sms-voice-v2-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-pinpoint-sms-voice-v2-spec:2023.09.22&quot; ✅ proton​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-proton-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-proton-spec:2023.09.22&quot; ✅ qldb-session​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-qldb-session-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-qldb-session-spec:2023.09.22&quot; ✅ route53-recovery-cluster​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-route53-recovery-cluster-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-route53-recovery-cluster-spec:2023.09.22&quot; ✅ sfn​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-sfn-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-sfn-spec:2023.09.22&quot; ✅ swf​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-swf-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-swf-spec:2023.09.22&quot; ✅ timestream-query​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-timestream-query-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-timestream-query-spec:2023.09.22&quot; ✅ timestream-write​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-timestream-write-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-timestream-write-spec:2023.09.22&quot; ✅ verifiedpermissions​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-verifiedpermissions-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-verifiedpermissions-spec:2023.09.22&quot; ✅ voice-id​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-voice-id-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-voice-id-spec:2023.09.22&quot; ","version":"Next","tagName":"h3"},{"title":"awsJson1_1​","type":1,"pageTitle":"AWS","url":"/smithy4s/docs/protocols/aws/aws#awsjson1_1","content":"✅ acm-pca​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-acm-pca-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-acm-pca-spec:2023.09.22&quot; ✅ acm​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-acm-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-acm-spec:2023.09.22&quot; ✅ alexa-for-business​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-alexa-for-business-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-alexa-for-business-spec:2023.09.22&quot; ✅ application-auto-scaling​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-application-auto-scaling-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-application-auto-scaling-spec:2023.09.22&quot; ✅ application-discovery-service​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-application-discovery-service-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-application-discovery-service-spec:2023.09.22&quot; ✅ application-insights​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-application-insights-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-application-insights-spec:2023.09.22&quot; ✅ appstream​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-appstream-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-appstream-spec:2023.09.22&quot; ✅ athena​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-athena-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-athena-spec:2023.09.22&quot; ✅ auto-scaling-plans​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-auto-scaling-plans-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-auto-scaling-plans-spec:2023.09.22&quot; ✅ budgets​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-budgets-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-budgets-spec:2023.09.22&quot; ✅ cloud9​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-cloud9-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-cloud9-spec:2023.09.22&quot; ✅ cloudhsm-v2​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-cloudhsm-v2-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-cloudhsm-v2-spec:2023.09.22&quot; ✅ cloudhsm​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-cloudhsm-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-cloudhsm-spec:2023.09.22&quot; ✅ cloudtrail​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-cloudtrail-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-cloudtrail-spec:2023.09.22&quot; ✅ cloudwatch-events​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-cloudwatch-events-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-cloudwatch-events-spec:2023.09.22&quot; ✅ cloudwatch-logs​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-cloudwatch-logs-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-cloudwatch-logs-spec:2023.09.22&quot; ✅ codebuild​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-codebuild-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-codebuild-spec:2023.09.22&quot; ✅ codecommit​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-codecommit-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-codecommit-spec:2023.09.22&quot; ✅ codedeploy​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-codedeploy-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-codedeploy-spec:2023.09.22&quot; ✅ codepipeline​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-codepipeline-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-codepipeline-spec:2023.09.22&quot; ✅ codestar​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-codestar-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-codestar-spec:2023.09.22&quot; ✅ cognito-identity-provider​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-cognito-identity-provider-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-cognito-identity-provider-spec:2023.09.22&quot; ✅ cognito-identity​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-cognito-identity-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-cognito-identity-spec:2023.09.22&quot; ✅ comprehend​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-comprehend-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-comprehend-spec:2023.09.22&quot; ✅ comprehendmedical​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-comprehendmedical-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-comprehendmedical-spec:2023.09.22&quot; ✅ config-service​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-config-service-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-config-service-spec:2023.09.22&quot; ✅ cost-and-usage-report-service​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-cost-and-usage-report-service-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-cost-and-usage-report-service-spec:2023.09.22&quot; ✅ cost-explorer​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-cost-explorer-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-cost-explorer-spec:2023.09.22&quot; ✅ data-pipeline​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-data-pipeline-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-data-pipeline-spec:2023.09.22&quot; ✅ database-migration-service​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-database-migration-service-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-database-migration-service-spec:2023.09.22&quot; ✅ datasync​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-datasync-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-datasync-spec:2023.09.22&quot; ✅ dax​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-dax-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-dax-spec:2023.09.22&quot; ✅ device-farm​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-device-farm-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-device-farm-spec:2023.09.22&quot; ✅ direct-connect​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-direct-connect-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-direct-connect-spec:2023.09.22&quot; ✅ directory-service​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-directory-service-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-directory-service-spec:2023.09.22&quot; ✅ ec2-instance-connect​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-ec2-instance-connect-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-ec2-instance-connect-spec:2023.09.22&quot; ✅ ecr-public​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-ecr-public-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-ecr-public-spec:2023.09.22&quot; ✅ ecr​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-ecr-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-ecr-spec:2023.09.22&quot; ✅ ecs​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-ecs-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-ecs-spec:2023.09.22&quot; ✅ emr​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-emr-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-emr-spec:2023.09.22&quot; ✅ eventbridge​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-eventbridge-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-eventbridge-spec:2023.09.22&quot; ✅ firehose​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-firehose-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-firehose-spec:2023.09.22&quot; ✅ fms​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-fms-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-fms-spec:2023.09.22&quot; ✅ forecast​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-forecast-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-forecast-spec:2023.09.22&quot; ✅ forecastquery​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-forecastquery-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-forecastquery-spec:2023.09.22&quot; ✅ frauddetector​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-frauddetector-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-frauddetector-spec:2023.09.22&quot; ✅ fsx​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-fsx-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-fsx-spec:2023.09.22&quot; ✅ gamelift​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-gamelift-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-gamelift-spec:2023.09.22&quot; ✅ global-accelerator​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-global-accelerator-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-global-accelerator-spec:2023.09.22&quot; ✅ glue​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-glue-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-glue-spec:2023.09.22&quot; ✅ health​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-health-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-health-spec:2023.09.22&quot; ✅ identitystore​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-identitystore-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-identitystore-spec:2023.09.22&quot; ✅ inspector​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-inspector-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-inspector-spec:2023.09.22&quot; ✅ iotsecuretunneling​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-iotsecuretunneling-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-iotsecuretunneling-spec:2023.09.22&quot; ✅ iotthingsgraph​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-iotthingsgraph-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-iotthingsgraph-spec:2023.09.22&quot; ✅ kendra​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-kendra-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-kendra-spec:2023.09.22&quot; ✅ kinesis-analytics-v2​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-kinesis-analytics-v2-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-kinesis-analytics-v2-spec:2023.09.22&quot; ✅ kinesis-analytics​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-kinesis-analytics-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-kinesis-analytics-spec:2023.09.22&quot; ⚠️ kinesis​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-kinesis-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-kinesis-spec:2023.09.22&quot; Unsupported streaming operations SubscribeToShard ✅ kms​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-kms-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-kms-spec:2023.09.22&quot; ✅ license-manager​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-license-manager-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-license-manager-spec:2023.09.22&quot; ✅ lightsail​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-lightsail-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-lightsail-spec:2023.09.22&quot; ✅ machine-learning​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-machine-learning-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-machine-learning-spec:2023.09.22&quot; ✅ macie​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-macie-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-macie-spec:2023.09.22&quot; ✅ marketplace-commerce-analytics​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-marketplace-commerce-analytics-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-marketplace-commerce-analytics-spec:2023.09.22&quot; ✅ marketplace-entitlement-service​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-marketplace-entitlement-service-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-marketplace-entitlement-service-spec:2023.09.22&quot; ✅ marketplace-metering​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-marketplace-metering-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-marketplace-metering-spec:2023.09.22&quot; ✅ mediastore​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-mediastore-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-mediastore-spec:2023.09.22&quot; ✅ memorydb​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-memorydb-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-memorydb-spec:2023.09.22&quot; ✅ migration-hub​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-migration-hub-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-migration-hub-spec:2023.09.22&quot; ✅ migrationhub-config​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-migrationhub-config-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-migrationhub-config-spec:2023.09.22&quot; ✅ mturk​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-mturk-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-mturk-spec:2023.09.22&quot; ✅ opsworks​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-opsworks-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-opsworks-spec:2023.09.22&quot; ✅ opsworkscm​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-opsworkscm-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-opsworkscm-spec:2023.09.22&quot; ✅ organizations​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-organizations-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-organizations-spec:2023.09.22&quot; ✅ personalize​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-personalize-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-personalize-spec:2023.09.22&quot; ✅ pi​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-pi-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-pi-spec:2023.09.22&quot; ✅ pricing​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-pricing-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-pricing-spec:2023.09.22&quot; ✅ redshift-data​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-redshift-data-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-redshift-data-spec:2023.09.22&quot; ✅ redshift-serverless​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-redshift-serverless-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-redshift-serverless-spec:2023.09.22&quot; ✅ rekognition​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-rekognition-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-rekognition-spec:2023.09.22&quot; ✅ resource-groups-tagging-api​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-resource-groups-tagging-api-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-resource-groups-tagging-api-spec:2023.09.22&quot; ✅ route-53-domains​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-route-53-domains-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-route-53-domains-spec:2023.09.22&quot; ✅ route53resolver​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-route53resolver-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-route53resolver-spec:2023.09.22&quot; ✅ sagemaker​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-sagemaker-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-sagemaker-spec:2023.09.22&quot; ✅ secrets-manager​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-secrets-manager-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-secrets-manager-spec:2023.09.22&quot; ✅ service-catalog​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-service-catalog-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-service-catalog-spec:2023.09.22&quot; ✅ service-quotas​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-service-quotas-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-service-quotas-spec:2023.09.22&quot; ✅ servicediscovery​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-servicediscovery-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-servicediscovery-spec:2023.09.22&quot; ✅ shield​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-shield-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-shield-spec:2023.09.22&quot; ✅ sms​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-sms-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-sms-spec:2023.09.22&quot; ✅ snowball​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-snowball-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-snowball-spec:2023.09.22&quot; ✅ ssm-contacts​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-ssm-contacts-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-ssm-contacts-spec:2023.09.22&quot; ✅ ssm​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-ssm-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-ssm-spec:2023.09.22&quot; ✅ sso-admin​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-sso-admin-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-sso-admin-spec:2023.09.22&quot; ✅ storage-gateway​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-storage-gateway-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-storage-gateway-spec:2023.09.22&quot; ✅ support​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-support-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-support-spec:2023.09.22&quot; ✅ textract​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-textract-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-textract-spec:2023.09.22&quot; ✅ transcribe​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-transcribe-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-transcribe-spec:2023.09.22&quot; ✅ transfer​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-transfer-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-transfer-spec:2023.09.22&quot; ✅ translate​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-translate-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-translate-spec:2023.09.22&quot; ✅ waf-regional​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-waf-regional-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-waf-regional-spec:2023.09.22&quot; ✅ waf​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-waf-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-waf-spec:2023.09.22&quot; ✅ wafv2​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-wafv2-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-wafv2-spec:2023.09.22&quot; ✅ workmail​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-workmail-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-workmail-spec:2023.09.22&quot; ✅ workspaces​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-workspaces-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-workspaces-spec:2023.09.22&quot; ","version":"Next","tagName":"h3"},{"title":"restXml​","type":1,"pageTitle":"AWS","url":"/smithy4s/docs/protocols/aws/aws#restxml","content":"✅ cloudfront​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-cloudfront-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-cloudfront-spec:2023.09.22&quot; ✅ route-53​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-route-53-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-route-53-spec:2023.09.22&quot; ✅ s3-control​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-s3-control-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-s3-control-spec:2023.09.22&quot; ⚠️ s3​ sbt: &quot;com.disneystreaming.smithy&quot; % &quot;aws-s3-spec&quot; % &quot;2023.09.22&quot;mill: ivy&quot;com.disneystreaming.smithy:aws-s3-spec:2023.09.22&quot; Unsupported streaming operations WriteGetObjectResponseUploadPartSelectObjectContentPutObjectGetObjectTorrentGetObject ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}