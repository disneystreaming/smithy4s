"use strict";(self.webpackChunksmithy4s=self.webpackChunksmithy4s||[]).push([[3459],{3905:(e,r,t)=>{t.d(r,{Zo:()=>u,kt:()=>d});var n=t(7294);function o(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function a(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?a(Object(t),!0).forEach((function(r){o(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function s(e,r){if(null==e)return{};var t,n,o=function(e,r){if(null==e)return{};var t,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)t=a[n],r.indexOf(t)>=0||(o[t]=e[t]);return o}(e,r);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)t=a[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=n.createContext({}),l=function(e){var r=n.useContext(c),t=r;return e&&(t="function"==typeof e?e(r):i(i({},r),e)),t},u=function(e){var r=l(e.components);return n.createElement(c.Provider,{value:r},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},h=n.forwardRef((function(e,r){var t=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=l(t),h=o,d=p["".concat(c,".").concat(h)]||p[h]||m[h]||a;return t?n.createElement(d,i(i({ref:r},u),{},{components:t})):n.createElement(d,i({ref:r},u))}));function d(e,r){var t=arguments,o=r&&r.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=h;var s={};for(var c in r)hasOwnProperty.call(r,c)&&(s[c]=r[c]);s.originalType=e,s[p]="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=t[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,t)}h.displayName="MDXCreateElement"},5261:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var n=t(7462),o=(t(7294),t(3905));const a={sidebar_label:"Smithy4s Transformations",title:"Smithy4s Transformations and generalisation"},i=void 0,s={unversionedId:"guides/smithy4s-transformations",id:"guides/smithy4s-transformations",title:"Smithy4s Transformations and generalisation",description:"It is often the case that users may want to manipulate the generated interfaces in a generic way, be that to transform the context in which the interface operates, or to apply some generic behaviour when running methods.",source:"@site/../docs/target/jvm-2.13/mdoc/06-guides/smithy4s-transformations.md",sourceDirName:"06-guides",slug:"/guides/smithy4s-transformations",permalink:"/smithy4s/docs/guides/smithy4s-transformations",draft:!1,editUrl:"https://github.com/disneystreaming/smithy4s/edit/main/modules/docs/src/06-guides/smithy4s-transformations.md",tags:[],version:"current",frontMatter:{sidebar_label:"Smithy4s Transformations",title:"Smithy4s Transformations and generalisation"},sidebar:"tutorialSidebar",previous:{title:"Model preprocessing",permalink:"/smithy4s/docs/guides/model-preprocessing"},next:{title:"Testing",permalink:"/smithy4s/docs/guides/testing"}},c={},l=[{value:"Error-related transformations",id:"error-related-transformations",level:2},{value:"Surfacing errors",id:"surfacing-errors",level:3},{value:"Absorbing errors",id:"absorbing-errors",level:3}],u={toc:l},p="wrapper";function m(e){let{components:r,...t}=e;return(0,o.kt)(p,(0,n.Z)({},u,t,{components:r,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"It is often the case that users may want to manipulate the generated interfaces in a generic way, be that to transform the context in which the interface operates, or to apply some generic behaviour when running methods."),(0,o.kt)("p",null,"The generated code provided by Smithy4s contains the required methods and instances to be able to write transformations very generically. In particular, all generated service interfaces come with an associated ",(0,o.kt)("inlineCode",{parentName:"p"},"FunctorK5"),', which means they can be "mapped" by using a function that\noperates over higher-kinded types with 5 type parameters. Yes, this is scary, but indirections are present to make it easier for the end user.'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'$version: "2"\n\nnamespace foo\n\nservice GreetService {\n  operations: [Greet]\n}\n\noperation Greet {\n  input := {\n    @required\n    name: String\n  }\n  output := {\n    @required\n    message: String\n  }\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import smithy4s._\nimport smithy4s.kinds.PolyFunction\nimport foo._\n\ntype Result[A] = Either[String, A]\n\n// Assuming `GreetService` was generated by smithy4s.\nval greetServiceEither: GreetService[Result] = new GreetService[Result]{\n  def greet(name: String): Result[GreetOutput] =\n    if (name.isEmpty) Left("What\'s your name ?")\n    else Right(GreetOutput(s"Hello $name!"))\n}\n// greetServiceEither: GreetService[Result] = repl.MdocSession$MdocApp$$anon$1@6007c348\n\n// Creating a polymorphic function turning Either to Option :\nval toOption: PolyFunction[Result, Option] = new PolyFunction[Result, Option]{\n  def apply[A](result: Result[A]): Option[A] = result.toOption\n}\n// toOption: PolyFunction[Result, Option] = repl.MdocSession$MdocApp$$anon$2@5a94141f\n\n// transforming our service :\nval greetServiceOption: GreetService[Option] = greetServiceEither.transform(toOption)\n// greetServiceOption: GreetService[Option] = foo.GreetServiceOperation$Transformed@4caa29ed\n\nprintln(greetServiceOption.greet("John"))\n// Some(GreetOutput(Hello John!))\n')),(0,o.kt)("h2",{id:"error-related-transformations"},"Error-related transformations"),(0,o.kt)("p",null,"Using transformations, it is possible to surface errors into the context a service operates, or, in the contrary, to absorb errors to make them disappear from the context. The generated interfaces contain the accurate information associated to each method, and the companion objects contain the necessary constructs to transform typed-errors into throwables and to recover type-errors from throwables."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'namespace smithy4s.example\n\nservice KVStore {\n  operations: [Get, Put, Delete],\n  errors: [UnauthorizedError]\n}\n\noperation Put {\n  input: KeyValue\n}\n\noperation Get {\n  input: Key,\n  output: Value,\n  errors: [KeyNotFoundError]\n}\n\noperation Delete {\n  input: Key,\n  errors: [KeyNotFoundError]\n}\n\nstructure Key {\n  @required\n  key: String\n}\n\nstructure KeyValue {\n  @required\n  key: String,\n  @required\n  value: String\n}\n\nstructure Value {\n  @required\n  value: String\n}\n\n@error("client")\nstructure UnauthorizedError {\n  @required\n  reason: String\n}\n\n@error("client")\nstructure KeyNotFoundError {\n  @required\n  message: String\n}\n')),(0,o.kt)("h3",{id:"surfacing-errors"},"Surfacing errors"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"smithy4s.Transformation.SurfaceError")," interface codifies the transformation of service implementations from contexts that represent errors as a generic ",(0,o.kt)("inlineCode",{parentName:"p"},"Throwable"),", from contexts that have the awareness of the errors specified in the specifications. It is useful when you want to exhaustively handle the errors that are specified (as opposed to letting them propagate)."),(0,o.kt)("p",null,"To make the ascription of such contexts easier, Smithy4s generates ",(0,o.kt)("inlineCode",{parentName:"p"},"ErrorAware[F[_, _]]"),' type aliases in the companion objects of services. This can\nbe used conjointly with types that have "two" parameters, one for the error, one for the result. For instance ',(0,o.kt)("inlineCode",{parentName:"p"},"type BIO[E, A] = EitherT[IO, E, A]"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import smithy4s.example._\nimport smithy4s.example.KVStore\nimport smithy4s.Transformation\nimport scala.util.{Failure, Success, Try}\n\nobject kvStoreTry extends KVStore[Try] {\n  def delete(key: String): Try[Unit] = Success(())\n  def put(key: String, value: String): Try[Unit] = Success(())\n  def get(key: String): Failure[Value] = Failure(KeyNotFoundError(s"Key $key wasn\'t found"))\n}\n\n// SurfaceError allows to go from mono-functor to bi-functor, for instance, from\n// IO[A] to EitherT[IO, E, A]\nval toEither: Transformation.SurfaceError[Try, Either] =\n  new Transformation.SurfaceError[Try, Either] {\n    def apply[E, A](\n        value: Try[A],\n        catcher: Throwable => Option[E]\n    ): Either[E, A] = value match {\n      case Success(value) => Right(value)\n      case Failure(error) =>\n        catcher(error) match {\n          case None    => throw error // don\'t do this at work!\n          case Some(e) => Left(e)\n        }\n    }\n  }\n// toEither: Transformation.SurfaceError[Try, Either] = repl.MdocSession$MdocApp$$anon$3@6994d437\n\nval kvStoreEither: KVStore.ErrorAware[Either] = kvStoreTry.transform(toEither)\n// kvStoreEither: KVStore.ErrorAware[Either] = smithy4s.example.KVStoreOperation$Transformed@30b3b460\nval result: Either[KVStore.GetError, Value] = kvStoreEither.get("foo")\n// result: Either[KVStore.GetError, Value] = Left(\n//   value = KeyNotFoundErrorCase(\n//     keyNotFoundError = KeyNotFoundError(message = "Key foo wasn\'t found")\n//   )\n// )\n')),(0,o.kt)("h3",{id:"absorbing-errors"},"Absorbing errors"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"smithy4s.Transformation.AbsorbErrors")," interface is the opposite as the ",(0,o.kt)("inlineCode",{parentName:"p"},"SurfaceError"),": it codifies the absorption of errors known by the service into generic error channels."),(0,o.kt)("p",null,"It is useful to implement services in a way that leverages the type-checker to ensure that the returned errors have been specified in Smithy,\nbefore passing the implementation to a generic router that is only able to work against a monofunctor."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import smithy4s.example._\nimport smithy4s.example.KVStore\nimport smithy4s.Transformation\nimport scala.util.{Failure, Success, Try}\n\nobject kvStoreEither extends KVStore.ErrorAware[Either] {\n  def delete(key: String): Either[KVStore.DeleteError, Unit] = Right(())\n  def put(key: String, value: String): Either[Nothing, Unit] = Right(())\n  def get(key: String): Either[KVStore.GetError, Value] =\n    Left(\n      KVStore.GetError.KeyNotFoundErrorCase(\n        KeyNotFoundError(s"Key $key wasn\'t found")\n      )\n    )\n}\n\nval toTry: Transformation.AbsorbError[Either, Try] =\n  new Transformation.AbsorbError[Either, Try] {\n    def apply[E, A](\n        value: Either[E, A],\n        thrower: E => Throwable\n    ): Try[A] = value match {\n      case Left(error)  => Failure(thrower(error))\n      case Right(value) => Success(value)\n    }\n  }\n// toTry: Transformation.AbsorbError[Either, Try] = repl.MdocSession$MdocApp3$$anon$4@6dc86cd7\n\nval kvStoreTry: KVStore[Try] = kvStoreEither.transform(toTry)\n// kvStoreTry: KVStore[Try] = smithy4s.example.KVStoreOperation$Transformed@130432d9\nval result: Try[Value] = kvStoreTry.get("foo")\n// result: Try[Value] = Failure(\n//   exception = KeyNotFoundError(message = "Key foo wasn\'t found")\n// )\n')))}m.isMDXComponent=!0}}]);