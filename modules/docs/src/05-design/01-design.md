---
sidebar_label: General design principles 
title: General design principles 
---

Before we dive in the design elements, it is important to state that smithy4s is designed with the following constraints : 

* optimised for number of usecases : smithy4s is **not** an just related to http/json, it can/could be used for a great many things, such as AWS SDKs, CLIs, UIs, etc. Therefore, following the protocol-agnostic nature of smithy, the code generated by smithy4s is not biased towards any protocol or serialisation mechanism, nor any runtime or Scala version. 
* optimised for correctness over compatibilty : there is strictly no guarantee made regarding backward compability of the generated code when users evolve their smithy schemas. Therefore, users are expected to regenerate the code at use-site, instead of relying on artifacts that would contain the generated code ... However, users do get idiomatic Scala code, including case classes / sealed traits (which are notoriously hard to evolve in binary compatible ways), and that generated code correctly reflects the smithy specifications. 
* decoupled from third party libraries : the generated core depends only on smithy4s-core for compilation, which does not pull third-party dependency (not even general purpose library that the maintainers love, like cats)

These constraints may sound counter-intuitive, obtuse, even alien ... and the internals of this library are not beginner friendly, and rely on advanced features from the Scala compiler that may unfortunately scare away newcomers interested to contribute. If you're not discouraged yet, do not hesitate to ask questions using github discussions, we will do our best to answer them ! 


