---
sidebar_label: Datatypes and schemas 
title: Datatypes and schemas 
---

As stated before, smithy4s does not generate code that depend on any third party library. But we want to use the generated code with specific serialisation technologies, such as json, or protobuf, or cbor, messagepack, xml (yes ... we know). 

We also want to avoid having to implement complex macros to allow for auto-derivation of these things. For starters, the reality is that maintainaing macros across two different Scala versions (2 and 3) is hard work. Secondly, macros close the door to an interesting feature, namely "dynamic schematisation" that we'll describe another chapter. 

If you have 45 minutes to waste, feel free to go watch the following video where Olivier explained the rationale behind the crazy pattern we are about to explain. Otherwise, head over below 

[![Revisiting visitors](https://img.youtube.com/vi/kvBX9u6uRaE/0.jpg)](https://www.youtube.com/watch?v=kvBX9u6uRaE)

## The Schema GADT 

Each datatype generated by smithy4s is accompanied by a `schema` value in its companion object, which receives an expression of type `smithy4s.schema.Schema` that captures everything needed to deconstruct/reconstruct instances of the datatype.

`smithy4s.schema.Schema` is a Generalised Algebraic Datatype (or GADT for short) that can be used to precisely references all the information needed to traverse datatypes that can be expressed in smithy. It is a bit like jvm-reflection, except that it exposes higher level information about the datatypes, via building blocks that accurately reflect what is possible to express in the smithy language. These building blocks form a **metamodel** : a model for models. And, unlike jvm-reflection, using schemas is type-safe. 

The `Schema` type reflects the various ways of constructing data types in smithy. It is encoded as a sealed trait, the members of which capture the following aspects of the smithy languages : 

* Primitives
* Lists
* Sets
* Maps
* Enumerations
* Structures
* Unions

For a scala type called `Foo`, formulating a `Schema[Foo]` is equivalent to exhaustively capturing the information needed for the serialisation and deserialisation of `Foo` in any format (json, xml, ...). Indeed, for any `Codec[_]` construct provided by third party libraries, it is possible to write a generic `def compile(schema: Schema[A]) : Codec[A]` function that produces the `Codec` for `A` based on the information held by the `Schema`. 

Why do things this way ? Why not just render `Codec` during code-generation ? The reason is that we want for the generated code to be completely decoupled from any serialisation format of library, and for the user to have the ability to wire that generated code in different ways, without having to change anything in the build. Moreover, this approach has proven that it allows for a bounded investment for adding interop with various libraries, and offers really good testability. 

### Hints 

In smithy, all shapes (and members of composite shapes) can be annotated with `traits`. Smithy4s generically translates these annotations to instances of the corresponding generated classes, which means that smithy4s supports generating user defined traits that it has zero knowledge of. 

So if you have the following smithy description: 

```kotlin 
namespace example

@trait 
structure metadata {
  @required
  description: String
}

@metadata(description: "This is my own integer shape")
integer MyInt 
```

When processing this smithy model, smithy4s renders a `case class Metadata(description: String)`, with an assocaited `ShapeTag[Metadata]` instance, and the following expression in the companion object of `MyInt` : 

```scala
val hints = Hints(
  Metadata("this is my own integer shape)
)
```

The `smithy4s.Hints` type is a polymorphic map that can hold shapes, keyed by `ShapeTag`. A `ShapeTag` is basically a uniquely identified tag that uses referential equality. Every schema can hold a `Hints` instance, which means that in additiona to the datatype structures, Schemas also offer an accurate reflection of the trait values that annotate shapes in the smithy models. 

Smithy4s uses these hints to implement interpreters. For instance, the `smithy.api#jsonName` smithy trait translates to a `smithy.api.JsonName` Scala type, that we can query from a `Hints` instance when implementing a `Schema ~> JsonCodec` transformation. This allows to give users a little customisability in 
the json serialisation of their datatypes. 



#### Structures  

A structure, also referred to as product, or record, is a construct that groups several values together. Typically, it translates naturally to a case class. 

```kotlin
namespace example 

structure Foo {
  @required 
  a: Integer,
  @length(min: 1)
  b: String, 
}
```

... and the associated, generated Scala code: 

```scala
package example

import smithy4s.schema.Schema._

case class Foo(a: Int, b: Option[String] = None)

object Foo extends smithy4s.ShapeTag.Companion[Foo] {
  val id: smithy4s.ShapeId = smithy4s.ShapeId("example", "Foo")

  implicit val schema: smithy4s.Schema[Foo] = struct(
    int.required[Foo]("a", _.a),
    string.optional[Foo]("b", _.b).addHints(smithy.api.Length(Some(1), None)) 
  ){
    Foo.apply
  }.withId(id)
}
```

As you can see, the smithy **structure** translates quite naturally to a Scala **case-class**. 
Every member of the structure that does not have the `@required` trait is rendered as an Optional value defaulting to None (by default, smithy4s sorts the fields before rendering the case class so that the required ones appear before the optional ones. That is a pragmatic decision that tends to improve UX for users.)

Indeed, for each field, there is an associated reference to a schema (int, string, ...), a string label, and a lambda calling the case class accessor that allows the retrieval of the associated field value. Additionally, the constructor of the case class is also referenced in the Schema. 

Typically, the accessors are needed for encoding the data, which involves destructuring it to access its individual components. The labels are there to cater to serialisation mechanisms like Json or Xml, which apply some labelled nesting on component data. 

Conversely, the constructor is used for deserialisation, which involves reconstructing the data after all of its component values have been successfully deserialised. 

Another detail is the presence of the `addHints` call on field labelled with `b`. This is due to the presence of the `length` trait (from the `smithy.api` namespace, aka prelude) on the corresponding `b` member of the smithy `Foo` shape. 

#### Note related to `optional` and `required` 

You may have noticed the `required` and `optional` methods, which create `Field` instances from `Schemas`, in order to pass them to structures. 
In smithy4s, the concept of `Option` only exists relatively to `struct` calls. It is not possible to construct a `Schema[Option[A]]` on its own. 

The rationale is that having a first class `Option` schema constructor leads to leakings in implementations of serialisation mechanisms, as `None` typically represents the absence of value, and allowing for serialising an absence of value in formats that typically do not support it implies the leak of `Option` (or equivalent) in various interfaces. 

Additionally, a first class `Option` schema constructor would allow to create schemas for `Option[Option[Option[Int]]]`, and even though we recognise that 
there are some things that could be encoded this way, it is just not a very pragmatic possibility, and opens the door for easy violation of round-trip properties that any serialisation technology should respect (for instance `Some(None)` and `None` can easily have the same encoding in Json, so how do you distinguish between the two during decoding).

### Unions 

A union, also referred to as coproduct, or sum type, is a construct that expresses sealed polymorphism. It is the dual of structure : 
when structures express that you have **A AND B**, unions express that you can have **A OR B**. 

The way this is expressed in smithy looks like this : 

```kotlin
namespace example 

union Bar {
  a: Integer,
  b: String
}
``` 

This hints at the default serialisation that AWS has intended to use on unions expressed in smithy, namely `tagged unions`. Indeed, the AWS json-centric protocols define that shapes like these should be serialised in objects with a single key/value entry, where the key receives the value of the tag. For instance, `{ "a" : 1 }` or `{ "b" : "two" }`. There are some very relevant technical reasons for it, but way of encoding unions/coproducts in json is arguably the best. 

Regarding the Scala code rendered by smithy4s, it looks like this : 

```scala
package example

import smithy4s.schema.Schema._

sealed trait Bar extends scala.Product with scala.Serializable
object Bar extends smithy4s.ShapeTag.Companion[Bar] {
  val id: smithy4s.ShapeId = smithy4s.ShapeId("foobar", "Bar")

  case class ACase(a: Int) extends Bar
  case class BCase(b: String) extends Bar

  object ACase {
    val hints : smithy4s.Hints = smithy4s.Hints.empty
    val schema: smithy4s.Schema[ACase] = bijection(int.addHints(hints), ACase(_), _.a)
    val alt = schema.oneOf[Bar]("a")
  }
  object BCase {
    val hints : smithy4s.Hints = smithy4s.Hints.empty
    val schema: smithy4s.Schema[BCase] = bijection(string.addHints(hints), BCase(_), _.b)
    val alt = schema.oneOf[Bar]("b")
  }

  implicit val schema: smithy4s.Schema[Bar] = union(
    ACase.alt,
    BCase.alt,
  ){
    case c : ACase => ACase.alt(c)
    case c : BCase => BCase.alt(c)
  }.withId(id)
}
```

The `union` is rendered as an ADT (`sealed trait`), the members of which are single-value case classes wrapping values of the types referenced 
by the `union` member. The `Case` suffix is there as a way to reduce risk of collision between the generated code and other types. 

Each ADT member is accompanied with each own schema, which is **not** provided implicitly, in an effort to retain coherence in the typeclass instances, 
and avoid the situation where you'd have different behaviour during serialisation based on whether you've upcasted a member to the ADT. Additionally, the companion objects of each ADT members contain an `alt` value (for "alternative"), which is the union's equivalent to the structure's `field`. 

Much like a `field`, an `alt` contains a label, and can carry hints. But unlike a `field`, which contains an accessor, the `alt` contains the function to "inject" (upcast) the member into the union. This is useful for deserialisation, when after deserialising successfully a member of a union, you need to inject it into the ADT to return the expected type. 

As for the union's schema, it is somewhat similar to the structure's, in that it references all its alternative. But instead of a structure's constructor, 
we have a dispatch function instead, which contains a pattern match against all the possible members, and dispatches the "downcasted" value to its corresponding alternative. This is useful for serialisation, when the behaviour of the alternatives can only be applied to values of the corresponding type : "if my ADT is an A, then I serialise the A, and add a discriminating tag to the serialised A".


### Named simple shapes 

Smithy allows to create named shapes indexing what is commonly considered "primitive types" : 

```kotlin 
namespace example

integer MyInt 
```

Smithy4s translates this to a Scala `NewType` : a zero-overhead wrapper for Integers : 

```scala
package example

object MyInt extends Newtype[Int] {
  val id: smithy4s.ShapeId = smithy4s.ShapeId("foobar", "MyInt")
  val hints : smithy4s.Hints = smithy4s.Hints.empty
  val underlyingSchema : smithy4s.Schema[Int] = int.withId(id).addHints(hints)
  implicit val schema : smithy4s.Schema[MyInt] = bijection(underlyingSchema, MyInt(_), (_ : MyInt).value)
}
```

A `MyInt` type alias, pointing to the `MyInt.Type` type member, is rendered in the `example` package object, which makes it possible to write 
such code : 

```scala
val myInt: MyInt = MyInt(1)
// val int: Int = myInt // doesn't compile because MyInt is not an Int at compile time. 
val int: Int = myInt.value 
```

You may have noticed that the `schema` value is using `bijection`. Indeed, additionally to the GADT members stated previously, `Schema` also 
has a `BijectionSchema` member, which allows to apply bidirectional transformation on another Schemas. This is useful for the case of newtypes, as if we are able to derive a codec that can encodes and decodes, `Int`, it should be possbile to derive a codec that encodes and decodes `MyInt` 
