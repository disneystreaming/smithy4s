---
sidebar_label: Transformations and generalisation
title: Transformations and generalisation
---

It is often the case that users may want to manipulate the generated interfaces in a generic way, be that to transform the context in which the interface operates, or to apply some generic behaviour when running methods.

The generated code provided by Smithy4s contains the required methods and instances to be able to write transformations very generically. In particular, all generated service interfaces come with an associated `FunctorK5`, which means they can be "mapped" by using a function that
operates over higher-kinded types with 5 type parameters. Yes, this is scary, but indirections are present to make it easier for the end user.

```scala mdoc:passthrough
docs.InlineSmithyFile("greet.smithy")
```


```scala mdoc
import smithy4s._
import foo._

type Result[A] = Either[String, A]

// Assuming `GreetService` was generated by smithy4s.
val greetServiceEither: GreetService[Result] = new GreetService[Result]{
  def greet(name: String) : Result[GreetOutput] =
    if (name.isEmpty) Left("What's your name ?")
    else Right(GreetOutput(s"Hello $name!"))
}

// Creating a polymorphic function turning Either to Option :
val toOption: PolyFunction[Result, Option] = new PolyFunction[Result, Option]{
  def apply[A](result: Result[A]): Option[A] = result.toOption
}

// transforming our service :
val greetServiceOption: GreetService[Option] = greetServiceEither.transform(toOption)

println(greetServiceOption.greet("John"))
```

## Error-related transformations

Using transformations, it is possible to surface errors into the context a service operates, or, in the contrary, to absorb errors to make them disappear from the context. The generated interfaces contain the accurate information associated to each method, and the companion objects contain the necessary constructs to transform typed-errors into throwables and to recover type-errors from throwables.

```scala mdoc:passthrough
docs.InlineSmithyFile.fromSample("kvstore.smithy")
```

### Surfacing errors

The `smithy4s.Transformation.SurfaceError` interface codifies the transformation of service implementations from contexts that represent errors as a generic `Throwable`, from contexts that have the awareness of the errors specified in the specifications. It is useful when you want to exhaustively handle the errors that are specified (as opposed to letting them propagate).

To make the ascription of such contexts easier, Smithy4s generates `ErrorAware[F[_, _]]` type aliases in the companion objects of services. This can
be used conjointly with types that have "two" parameters, one for the error, one for the result. For instance `type BIO[E, A] = EitherT[IO, E, A]`.


```scala mdoc
import smithy4s.example._
import smithy4s.example.KVStore
import smithy4s.Transformation
import scala.util.{Failure, Success, Try}

object kvStoreTry extends KVStore[Try] {
  def delete(key: String): Try[Unit] = Success(())
  def put(key: String, value: String): Try[Unit] = Success(())
  def get(key: String): Failure[Value] = Failure(KeyNotFoundError(s"Key $key wasn't found"))
}

// SurfaceError allows to go from mono-functor to bi-functor, for instance, from
// IO[A] to EitherT[IO, E, A]
val toEither: Transformation.SurfaceError[Try, Either] =
  new Transformation.SurfaceError[Try, Either] {
    def apply[E, A](
        value: Try[A],
        catcher: Throwable => Option[E]
    ): Either[E, A] = value match {
      case Success(value) => Right(value)
      case Failure(error) =>
        catcher(error) match {
          case None    => throw error // don't do this at work!
          case Some(e) => Left(e)
        }
    }
  }

val kvStoreEither: KVStore.ErrorAware[Either] = kvStoreTry.transform(toEither)
val result: Either[KVStore.GetError, Value] = kvStoreEither.get("foo")
```

### Absorbing errors

The `smithy4s.Transformation.AbsorbErrors` interface is the opposite as the `SurfaceError` : it codifies the absorption of errors known by the service into generic error channels.

It is useful to implement services in a way that leverages the type-checker to ensure that the returned errors have been specified in Smithy,
before passing the implementation to a generic router that is only able to work against a monofunctor.

```scala mdoc:reset
import smithy4s.example._
import smithy4s.example.KVStore
import smithy4s.Transformation
import scala.util.{Failure, Success, Try}

object kvStoreEither extends KVStore.ErrorAware[Either] {
  def delete(key: String): Either[KVStore.DeleteError, Unit] = Right(())
  def put(key: String, value: String): Either[Nothing, Unit] = Right(())
  def get(key: String): Either[KVStore.GetError, Value] =
    Left(
      KVStore.GetError.KeyNotFoundErrorCase(
        KeyNotFoundError(s"Key $key wasn't found")
      )
    )
}

val toTry: Transformation.AbsorbError[Either, Try] =
  new Transformation.AbsorbError[Either, Try] {
    def apply[E, A](
        value: Either[E, A],
        thrower: E => Throwable
    ): Try[A] = value match {
      case Left(error)  => Failure(thrower(error))
      case Right(value) => Success(value)
    }
  }

val kvStoreTry: KVStore[Try] = kvStoreEither.transform(toTry)
val result: Try[Value] = kvStoreTry.get("foo")
```
