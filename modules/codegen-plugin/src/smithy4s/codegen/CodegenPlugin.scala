/*
 *  Copyright 2021-2022 Disney Streaming
 *
 *  Licensed under the Tomorrow Open Source Technology License, Version 1.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     https://disneystreaming.github.io/TOST-1.0.txt
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package smithy4s.codegen

import sbt.Keys._
import sbt.util.CacheImplicits._
import sbt.{fileJsonFormatter => _, _}

object Smithy4sCodegenPlugin extends AutoPlugin {
  override def requires = plugins.JvmPlugin

  object autoImport {
    val smithy4sCodegen =
      taskKey[Seq[File]](
        "Generate .scala and other files from smithy specs (.smithy or .json files)"
      )

    val smithy4sVersion =
      settingKey[String]("Smithy4sVersion")

    val smithy4sInputDir =
      settingKey[File](
        "Input directory for smithy specs (.smithy or .json files)"
      )

    val smithy4sOutputDir =
      settingKey[File](
        "Output directory for .scala files generated by smithy4s"
      )

    val smithy4sOpenapiDir =
      settingKey[File](
        "Output directory for openapi .json files generated by smithy4s"
      )

    val smithy4sAllowedNamespaces =
      settingKey[List[String]](
        "Allow-list of namespaces that should be processed by the generator. If unset, considers all namespaces but stdlib ones"
      )

    val smithy4sExcludedNamespaces =
      settingKey[List[String]](
        "Disallow-list of namespaces that should not be processed by the generator. When set, namespaces are evicted as the last filtering step"
      )

    @deprecated(
      "2022-03-01",
      """use `libraryDependencies += "org.acme" % "artifact" % "version" % Smithy4s`"""
    )
    val smithy4sCodegenDependencies =
      settingKey[List[String]](
        "List of dependencies containing smithy files to include in codegen task"
      )

    val Smithy4s =
      config("smithy4s").describedAs("Dependencies for Smithy code.")

    val smithy4sModelTransformers =
      settingKey[List[String]](
        "List of transformer names that should be applied to the model prior to codegen"
      )
  }

  import autoImport._

  override lazy val buildSettings = Seq(
    smithy4sVersion := BuildInfo.version
  )

  override def projectConfigurations: Seq[Configuration] = Seq(Smithy4s)

  override lazy val projectSettings =
    Seq(
      Compile / smithy4sInputDir := (Compile / sourceDirectory).value / "smithy",
      Compile / smithy4sOutputDir := (Compile / sourceManaged).value,
      Compile / smithy4sOpenapiDir := (Compile / resourceManaged).value,
      Compile / smithy4sCodegen := cachedSmithyCodegen(Compile).value,
      Compile / smithy4sCodegenDependencies := List.empty: @annotation.nowarn,
      Compile / sourceGenerators += (Compile / smithy4sCodegen).map(
        _.filter(_.ext == "scala")
      ),
      Compile / resourceGenerators += (Compile / smithy4sCodegen).map(
        _.filter(_.ext != "scala")
      ),
      cleanFiles += (Compile / smithy4sOutputDir).value,
      Compile / smithy4sModelTransformers := List.empty
    )

  private def untupled[A, B, C](f: ((A, B)) => C): (A, B) => C = (a, b) =>
    f((a, b))

  private type CacheKey = (
      FilesInfo[HashFileInfo],
      List[String]
  )

  private def prepareSmithy4sDeps(deps: Seq[ModuleID]): List[String] =
    deps
      .filter { _.configurations.contains(Smithy4s.name) }
      .map { m =>
        if (CrossVersion.disabled == m.crossVersion)
          s"${m.organization}:${m.name}:${m.revision}"
        else s"${m.organization}::${m.name}:${m.revision}"
      }
      .toList

  def cachedSmithyCodegen(conf: Configuration) = Def.task {
    val inputFiles =
      Option((conf / smithy4sInputDir).value.listFiles()).getOrElse(Array.empty)
    val outputPath = (conf / smithy4sOutputDir).value
    val openApiOutputPath = (conf / smithy4sOpenapiDir).value
    val allowedNamespaces =
      (conf / smithy4sAllowedNamespaces).?.value.map(_.toSet)
    val excludedNamespaces =
      (conf / smithy4sExcludedNamespaces).?.value.map(_.toSet)
    val dependencies = prepareSmithy4sDeps(libraryDependencies.value)
    val res =
      (conf / resolvers).value.toList.collect { case m: MavenRepository =>
        m.root
      }
    val transforms = (conf / smithy4sModelTransformers).value
    val s = streams.value

    val cached =
      Tracked.inputChanged[CacheKey, Seq[File]](
        s.cacheStoreFactory.make("input")
      ) {
        untupled {
          Tracked
            .lastOutput[(Boolean, CacheKey), Seq[File]](
              s.cacheStoreFactory.make("output")
            ) { case ((changed, _), outputs) =>
              if (changed || outputs.isEmpty) {
                val filePaths = inputFiles.map(_.getAbsolutePath())
                val codegenArgs = CodegenArgs(
                  filePaths.map(os.Path(_)).toList,
                  output = os.Path(outputPath),
                  openapiOutput = os.Path(openApiOutputPath),
                  skipScala = false,
                  skipOpenapi = false,
                  discoverModels = true, // we need protocol here
                  allowedNS = allowedNamespaces,
                  excludedNS = excludedNamespaces,
                  repositories = res,
                  dependencies = dependencies,
                  transforms
                )
                val resPaths = smithy4s.codegen.Codegen
                  .processSpecs(codegenArgs)
                  .toList
                resPaths.map(path => new File(path.toString))
              } else {
                outputs.getOrElse(Seq.empty)
              }
            }
        }
      }

    cached(
      (FilesInfo(inputFiles.map(FileInfo.hash(_)).toSet), dependencies)
    )
  }
}
